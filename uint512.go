// Code generated by 'gen'. DO NOT EDIT.

package fixed

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
	"sync"
)

// Uint512 is an unsigned, 512-bit integer.
//
// It can be compared for equality with ==.
type Uint512 struct {
	u0, u1, u2, u3, u4, u5, u6, u7 uint64
}

var _ Uint[Uint512] = Uint512{}

// U512 returns x as a Uint512.
func U512(x uint64) Uint512 {
	return Uint512{u0: x}
}

func u512(lo, hi Uint256) Uint512 {
	return Uint512{lo.u0, lo.u1, lo.u2, lo.u3, hi.u0, hi.u1, hi.u2, hi.u3}
}

func (Uint512) max() Uint512 {
	return Uint512{
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
	}
}

func (x Uint512) low() Uint256 {
	return Uint256{x.u0, x.u1, x.u2, x.u3}
}

func (x Uint512) high() Uint256 {
	return Uint256{x.u4, x.u5, x.u6, x.u7}
}

func (x Uint512) uint8() uint8 {
	return uint8(x.u0)
}

// Bytes encodes x as a little-endian integer.
func (x Uint512) Bytes(b *[64]byte) {
	binary.LittleEndian.PutUint64(b[0:], x.u0)
	binary.LittleEndian.PutUint64(b[8:], x.u1)
	binary.LittleEndian.PutUint64(b[16:], x.u2)
	binary.LittleEndian.PutUint64(b[24:], x.u3)
	binary.LittleEndian.PutUint64(b[32:], x.u4)
	binary.LittleEndian.PutUint64(b[40:], x.u5)
	binary.LittleEndian.PutUint64(b[48:], x.u6)
	binary.LittleEndian.PutUint64(b[56:], x.u7)

}

// SetBytes sets x to the encoded little-endian integer b.
func (x *Uint512) SetBytes(b []byte) error {
	if len(b) != 64 {
		return fmt.Errorf("fixed: invalid length: %d", len(b))
	}
	x.u0 = binary.LittleEndian.Uint64(b[0:])
	x.u1 = binary.LittleEndian.Uint64(b[8:])
	x.u2 = binary.LittleEndian.Uint64(b[16:])
	x.u3 = binary.LittleEndian.Uint64(b[24:])
	x.u4 = binary.LittleEndian.Uint64(b[32:])
	x.u5 = binary.LittleEndian.Uint64(b[40:])
	x.u6 = binary.LittleEndian.Uint64(b[48:])
	x.u7 = binary.LittleEndian.Uint64(b[56:])
	return nil
}

// Size returns the width of the integer in bits.
func (Uint512) Size() int {
	return 512
}

// BitLen returns the number of bits required to represent x.
func (x Uint512) BitLen() int {
	switch {
	case x.u7 != 0:
		return 448 + bits.Len64(x.u7)
	case x.u6 != 0:
		return 384 + bits.Len64(x.u6)
	case x.u5 != 0:
		return 320 + bits.Len64(x.u5)
	case x.u4 != 0:
		return 256 + bits.Len64(x.u4)
	case x.u3 != 0:
		return 192 + bits.Len64(x.u3)
	case x.u2 != 0:
		return 128 + bits.Len64(x.u2)
	case x.u1 != 0:
		return 64 + bits.Len64(x.u1)
	default:
		return bits.Len64(x.u0)
	}
}

// LeadingZeros returns the number of leading zeros in x.
func (x Uint512) LeadingZeros() int {
	return 512 - x.BitLen()
}

// IsZero is shorthand for x == Uint512{}.
func (x Uint512) IsZero() bool {
	return x == Uint512{}
}

// Cmp compares x and y and returns
//
//   - +1 if x > y
//   - 0 if x == y
//   - -1 if x < y
func (x Uint512) Cmp(y Uint512) int {
	switch {
	case x.u7 != y.u7:
		return cmp(x.u7, y.u7)
	case x.u6 != y.u6:
		return cmp(x.u6, y.u6)
	case x.u5 != y.u5:
		return cmp(x.u5, y.u5)
	case x.u4 != y.u4:
		return cmp(x.u4, y.u4)
	case x.u3 != y.u3:
		return cmp(x.u3, y.u3)
	case x.u2 != y.u2:
		return cmp(x.u2, y.u2)
	case x.u1 != y.u1:
		return cmp(x.u1, y.u1)
	default:
		return cmp(x.u0, y.u0)
	}
}

// cmp64 compares x and y and returns
//
//   - +1 if x > y
//   - 0 if x == y
//   - -1 if x < y
func (x Uint512) cmp64(y uint64) int {
	v := x
	v.u0 = 0
	if !v.IsZero() {
		return +1
	}
	return cmp(x.u0, y)
}

// Equal reports whether x == y.
//
// In general, prefer the == operator to using this method.
func (x Uint512) Equal(y Uint512) bool {
	return x == y
}

// And returns x&y.
func (x Uint512) And(y Uint512) Uint512 {
	return Uint512{
		x.u0 & y.u0,
		x.u1 & y.u1,
		x.u2 & y.u2,
		x.u3 & y.u3,
		x.u4 & y.u4,
		x.u5 & y.u5,
		x.u6 & y.u6,
		x.u7 & y.u7,
	}
}

// Or returns x|y.
func (x Uint512) Or(y Uint512) Uint512 {
	return Uint512{
		x.u0 | y.u0,
		x.u1 | y.u1,
		x.u2 | y.u2,
		x.u3 | y.u3,
		x.u4 | y.u4,
		x.u5 | y.u5,
		x.u6 | y.u6,
		x.u7 | y.u7,
	}
}

// orLsh64 returns x | y<<s.
func (x Uint512) orLsh64(y uint64, s uint) Uint512 {
	return x.Or(Uint512{u0: y}.Lsh(s))
}

// Xor returns x^y.
func (x Uint512) Xor(y Uint512) Uint512 {
	return Uint512{
		x.u0 ^ y.u0,
		x.u1 ^ y.u1,
		x.u2 ^ y.u2,
		x.u3 ^ y.u3,
		x.u4 ^ y.u4,
		x.u5 ^ y.u5,
		x.u6 ^ y.u6,
		x.u7 ^ y.u7,
	}
}

// Lsh returns x<<n.
func (x Uint512) Lsh(n uint) Uint512 {
	switch {
	case n > 448:
		s := n - 448
		return Uint512{
			u7: x.u0 << s,
		}
	case n > 384:
		s := n - 384
		ŝ := 64 - s
		return Uint512{
			u6: x.u0 << s,
			u7: x.u1<<s | x.u0>>ŝ,
		}
	case n > 320:
		s := n - 320
		ŝ := 64 - s
		return Uint512{
			u5: x.u0 << s,
			u6: x.u1<<s | x.u0>>ŝ,
			u7: x.u2<<s | x.u1>>ŝ,
		}
	case n > 256:
		s := n - 256
		ŝ := 64 - s
		return Uint512{
			u4: x.u0 << s,
			u5: x.u1<<s | x.u0>>ŝ,
			u6: x.u2<<s | x.u1>>ŝ,
			u7: x.u3<<s | x.u2>>ŝ,
		}
	case n > 192:
		s := n - 192
		ŝ := 64 - s
		return Uint512{
			u3: x.u0 << s,
			u4: x.u1<<s | x.u0>>ŝ,
			u5: x.u2<<s | x.u1>>ŝ,
			u6: x.u3<<s | x.u2>>ŝ,
			u7: x.u4<<s | x.u3>>ŝ,
		}
	case n > 128:
		s := n - 128
		ŝ := 64 - s
		return Uint512{
			u2: x.u0 << s,
			u3: x.u1<<s | x.u0>>ŝ,
			u4: x.u2<<s | x.u1>>ŝ,
			u5: x.u3<<s | x.u2>>ŝ,
			u6: x.u4<<s | x.u3>>ŝ,
			u7: x.u5<<s | x.u4>>ŝ,
		}
	case n > 64:
		s := n - 64
		ŝ := 64 - s
		return Uint512{
			u1: x.u0 << s,
			u2: x.u1<<s | x.u0>>ŝ,
			u3: x.u2<<s | x.u1>>ŝ,
			u4: x.u3<<s | x.u2>>ŝ,
			u5: x.u4<<s | x.u3>>ŝ,
			u6: x.u5<<s | x.u4>>ŝ,
			u7: x.u6<<s | x.u5>>ŝ,
		}
	default:
		s := n
		ŝ := 64 - s
		return Uint512{
			u0: x.u0 << s,
			u1: x.u1<<s | x.u0>>ŝ,
			u2: x.u2<<s | x.u1>>ŝ,
			u3: x.u3<<s | x.u2>>ŝ,
			u4: x.u4<<s | x.u3>>ŝ,
			u5: x.u5<<s | x.u4>>ŝ,
			u6: x.u6<<s | x.u5>>ŝ,
			u7: x.u7<<s | x.u6>>ŝ,
		}
	}
}

// Rsh returns x>>n.
func (x Uint512) Rsh(n uint) Uint512 {
	switch {
	case n > 448:
		s := n - 448
		return Uint512{
			u0: x.u7 >> s,
		}
	case n > 384:
		s := n - 384
		ŝ := 64 - s
		return Uint512{
			u0: x.u6>>s | x.u7<<ŝ,
			u1: x.u7 >> s,
		}
	case n > 320:
		s := n - 320
		ŝ := 64 - s
		return Uint512{
			u0: x.u5>>s | x.u6<<ŝ,
			u1: x.u6>>s | x.u7<<ŝ,
			u2: x.u7 >> s,
		}
	case n > 256:
		s := n - 256
		ŝ := 64 - s
		return Uint512{
			u0: x.u4>>s | x.u5<<ŝ,
			u1: x.u5>>s | x.u6<<ŝ,
			u2: x.u6>>s | x.u7<<ŝ,
			u3: x.u7 >> s,
		}
	case n > 192:
		s := n - 192
		ŝ := 64 - s
		return Uint512{
			u0: x.u3>>s | x.u4<<ŝ,
			u1: x.u4>>s | x.u5<<ŝ,
			u2: x.u5>>s | x.u6<<ŝ,
			u3: x.u6>>s | x.u7<<ŝ,
			u4: x.u7 >> s,
		}
	case n > 128:
		s := n - 128
		ŝ := 64 - s
		return Uint512{
			u0: x.u2>>s | x.u3<<ŝ,
			u1: x.u3>>s | x.u4<<ŝ,
			u2: x.u4>>s | x.u5<<ŝ,
			u3: x.u5>>s | x.u6<<ŝ,
			u4: x.u6>>s | x.u7<<ŝ,
			u5: x.u7 >> s,
		}
	case n > 64:
		s := n - 64
		ŝ := 64 - s
		return Uint512{
			u0: x.u1>>s | x.u2<<ŝ,
			u1: x.u2>>s | x.u3<<ŝ,
			u2: x.u3>>s | x.u4<<ŝ,
			u3: x.u4>>s | x.u5<<ŝ,
			u4: x.u5>>s | x.u6<<ŝ,
			u5: x.u6>>s | x.u7<<ŝ,
			u6: x.u7 >> s,
		}
	default:
		s := n
		ŝ := 64 - s
		return Uint512{
			u0: x.u0>>s | x.u1<<ŝ,
			u1: x.u1>>s | x.u2<<ŝ,
			u2: x.u2>>s | x.u3<<ŝ,
			u3: x.u3>>s | x.u4<<ŝ,
			u4: x.u4>>s | x.u5<<ŝ,
			u5: x.u5>>s | x.u6<<ŝ,
			u6: x.u6>>s | x.u7<<ŝ,
			u7: x.u7 >> s,
		}
	}
}

// Add returns x+y.
func (x Uint512) Add(y Uint512) Uint512 {
	var z Uint512
	var carry uint64
	z.u0, carry = bits.Add64(x.u0, y.u0, 0)
	z.u1, carry = bits.Add64(x.u1, y.u1, carry)
	z.u2, carry = bits.Add64(x.u2, y.u2, carry)
	z.u3, carry = bits.Add64(x.u3, y.u3, carry)
	z.u4, carry = bits.Add64(x.u4, y.u4, carry)
	z.u5, carry = bits.Add64(x.u5, y.u5, carry)
	z.u6, carry = bits.Add64(x.u6, y.u6, carry)
	z.u7, _ = bits.Add64(x.u7, y.u7, carry)
	return z
}

// add64 returns x+y.
func (x Uint512) add64(y uint64) Uint512 {
	var z Uint512
	var carry uint64
	z.u0, carry = bits.Add64(x.u0, y, 0)
	z.u1, carry = bits.Add64(x.u1, 0, carry)
	z.u2, carry = bits.Add64(x.u2, 0, carry)
	z.u3, carry = bits.Add64(x.u3, 0, carry)
	z.u4, carry = bits.Add64(x.u4, 0, carry)
	z.u5, carry = bits.Add64(x.u5, 0, carry)
	z.u6, carry = bits.Add64(x.u6, 0, carry)
	z.u7, _ = bits.Add64(x.u7, 0, carry)
	return z
}

// AddCheck returns x+y.
//
// carry is 1 if x+y overflows and 0 otherwise.
func (x Uint512) AddCheck(y Uint512) (z Uint512, carry uint64) {
	z.u0, carry = bits.Add64(x.u0, y.u0, 0)
	z.u1, carry = bits.Add64(x.u1, y.u1, carry)
	z.u2, carry = bits.Add64(x.u2, y.u2, carry)
	z.u3, carry = bits.Add64(x.u3, y.u3, carry)
	z.u4, carry = bits.Add64(x.u4, y.u4, carry)
	z.u5, carry = bits.Add64(x.u5, y.u5, carry)
	z.u6, carry = bits.Add64(x.u6, y.u6, carry)
	z.u7, carry = bits.Add64(x.u7, y.u7, carry)
	return z, carry
}

// addCheck64 returns x+y.
//
// carry is 1 if x+y overflows and 0 otherwise.
func (x Uint512) addCheck64(y uint64) (z Uint512, carry uint64) {
	z.u0, carry = bits.Add64(x.u0, y, 0)
	z.u1, carry = bits.Add64(x.u1, 0, carry)
	z.u2, carry = bits.Add64(x.u2, 0, carry)
	z.u3, carry = bits.Add64(x.u3, 0, carry)
	z.u4, carry = bits.Add64(x.u4, 0, carry)
	z.u5, carry = bits.Add64(x.u5, 0, carry)
	z.u6, carry = bits.Add64(x.u6, 0, carry)
	z.u7, carry = bits.Add64(x.u7, 0, carry)
	return z, carry
}

// Sub returns x-y.
func (x Uint512) Sub(y Uint512) Uint512 {
	var z Uint512
	var borrow uint64
	z.u0, borrow = bits.Sub64(x.u0, y.u0, 0)
	z.u1, borrow = bits.Sub64(x.u1, y.u1, borrow)
	z.u2, borrow = bits.Sub64(x.u2, y.u2, borrow)
	z.u3, borrow = bits.Sub64(x.u3, y.u3, borrow)
	z.u4, borrow = bits.Sub64(x.u4, y.u4, borrow)
	z.u5, borrow = bits.Sub64(x.u5, y.u5, borrow)
	z.u6, borrow = bits.Sub64(x.u6, y.u6, borrow)
	z.u7, _ = bits.Sub64(x.u7, y.u7, borrow)
	return z
}

// sub64 returns x-y.
func (x Uint512) sub64(y uint64) Uint512 {
	var z Uint512
	var borrow uint64
	z.u0, borrow = bits.Sub64(x.u0, y, 0)
	z.u1, borrow = bits.Sub64(x.u1, 0, borrow)
	z.u2, borrow = bits.Sub64(x.u2, 0, borrow)
	z.u3, borrow = bits.Sub64(x.u3, 0, borrow)
	z.u4, borrow = bits.Sub64(x.u4, 0, borrow)
	z.u5, borrow = bits.Sub64(x.u5, 0, borrow)
	z.u6, borrow = bits.Sub64(x.u6, 0, borrow)
	z.u7, _ = bits.Sub64(x.u7, 0, borrow)
	return z
}

// SubCheck returns x-y.
//
// borrow is 1 if x-y overflows and 0 otherwise.
func (x Uint512) SubCheck(y Uint512) (z Uint512, borrow uint64) {
	z.u0, borrow = bits.Sub64(x.u0, y.u0, 0)
	z.u1, borrow = bits.Sub64(x.u1, y.u1, borrow)
	z.u2, borrow = bits.Sub64(x.u2, y.u2, borrow)
	z.u3, borrow = bits.Sub64(x.u3, y.u3, borrow)
	z.u4, borrow = bits.Sub64(x.u4, y.u4, borrow)
	z.u5, borrow = bits.Sub64(x.u5, y.u5, borrow)
	z.u6, borrow = bits.Sub64(x.u6, y.u6, borrow)
	z.u7, borrow = bits.Sub64(x.u7, y.u7, borrow)
	return z, borrow
}

// subCheck64 returns x-y.
//
// borrow is 1 if x-y overflows and 0 otherwise.
func (x Uint512) subCheck64(y uint64) (z Uint512, borrow uint64) {
	z.u0, borrow = bits.Sub64(x.u0, y, 0)
	z.u1, borrow = bits.Sub64(x.u1, 0, borrow)
	z.u2, borrow = bits.Sub64(x.u2, 0, borrow)
	z.u3, borrow = bits.Sub64(x.u3, 0, borrow)
	z.u4, borrow = bits.Sub64(x.u4, 0, borrow)
	z.u5, borrow = bits.Sub64(x.u5, 0, borrow)
	z.u6, borrow = bits.Sub64(x.u6, 0, borrow)
	z.u7, borrow = bits.Sub64(x.u7, 0, borrow)
	return z, borrow
}

// Mul returns x*y.
func (x Uint512) Mul(y Uint512) Uint512 {
	var z Uint512
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		z.u7 += x.u7*d + c
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		z.u7 += x.u6*d + c
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		z.u7 += x.u5*d + c
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		z.u7 += x.u4*d + c
	}

	// y.u4 * x
	if d := y.u4; d != 0 {
		c, z.u4 = mulAddWWW(x.u0, d, z.u4)
		c, z.u5 = mulAddWWWW(x.u1, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u2, d, z.u6, c)
		z.u7 += x.u3*d + c
	}

	// y.u5 * x
	if d := y.u5; d != 0 {
		c, z.u5 = mulAddWWW(x.u0, d, z.u5)
		c, z.u6 = mulAddWWWW(x.u1, d, z.u6, c)
		z.u7 += x.u2*d + c
	}

	// y.u6 * x
	if d := y.u6; d != 0 {
		c, z.u6 = mulAddWWW(x.u0, d, z.u6)
		z.u7 += x.u1*d + c
	}

	// y.u7 * x
	if d := y.u7; d != 0 {
		z.u7 += x.u0 * d
	}

	return z
}

func (x Uint512) mul256(y Uint256) Uint512 {
	var z Uint512
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		z.u7 += x.u7*d + c
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		z.u7 += x.u6*d + c
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		z.u7 += x.u5*d + c
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		z.u7 += x.u4*d + c
	}

	return z
}

func (x Uint512) mul64(y uint64) Uint512 {
	if y == 0 {
		return Uint512{}
	}
	var z Uint512
	var c uint64
	c, z.u0 = bits.Mul64(x.u0, y)
	c, z.u1 = mulAddWWW(x.u1, y, c)
	c, z.u2 = mulAddWWW(x.u2, y, c)
	c, z.u3 = mulAddWWW(x.u3, y, c)
	c, z.u4 = mulAddWWW(x.u4, y, c)
	c, z.u5 = mulAddWWW(x.u5, y, c)
	c, z.u6 = mulAddWWW(x.u6, y, c)
	z.u7 += x.u7*y + c
	return z
}

// Exp return x^y mod m.
//
// If m == 0, Exp simply returns x^y.
func (x Uint512) Exp(y, m Uint512) Uint512 {
	const mask = 1 << (64 - 1)

	// x^0 = 1
	if y.IsZero() {
		return U512(1)
	}

	// x^1 mod m == x mod m
	mod := !m.IsZero()
	if y == U512(1) && mod {
		_, r := x.QuoRem(m)
		return r
	}

	yv := []uint64{
		y.u0, y.u1, y.u2, y.u3, y.u4, y.u5, y.u6,
	}
	i := len(yv)
	for i > 0 && yv[i-1] == 0 {
		i--
	}
	yv = yv[:i]

	// TODO(eric): if x > 1 and y > 0 && mod, then use montgomery
	// or windowed exponentiation.

	z := x
	v := yv[len(yv)-1]
	s := bits.LeadingZeros64(v) + 1
	v <<= s
	w := 64 - s
	for j := 0; j < w; j++ {
		z = z.Mul(z)
		if v&mask != 0 {
			z = z.Mul(x)
		}
		if mod {
			_, z = z.QuoRem(m)
		}
		v <<= 1
	}

	for i := len(yv) - 2; i >= 0; i-- {
		v := yv[i]
		for j := 0; j < 64; j++ {
			z = z.Mul(z)
			if v&mask != 0 {
				z = z.Mul(x)
			}
			if mod {
				_, z = z.QuoRem(m)
			}
			v <<= 1
		}
	}
	return z
}

// mulPow10 returns x * 10^n.
func (x Uint512) mulPow10(n uint) (Uint512, bool) {
	switch {
	case x.IsZero():
		return Uint512{}, true
	case n == 0:
		return x, true
	default:
		return x.MulCheck(U512(10).Exp(U512(uint64(n)), U512(0)))
	}
}

var pow10tabUint512 struct {
	values []Uint512
	once   sync.Once
}

func pow10Uint512(n uint) Uint512 {
	pow10tabUint512.once.Do(func() {
		tab := make([]Uint512, 2+155)
		tab[0] = Uint512{}
		tab[1] = U512(1)
		for i := 2; i < len(tab); i++ {
			tab[i] = tab[i-1].mul64(10)
		}
		pow10tabUint512.values = tab
	})
	return pow10tabUint512.values[n]
}

// MulCheck returns x*y and reports whether the multiplication
// oveflowed.
func (x Uint512) MulCheck(y Uint512) (Uint512, bool) {
	if x.BitLen()+y.BitLen() > 512 {
		return Uint512{}, false
	}

	var z Uint512
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		c, z.u7 = mulAddWWW(x.u7, d, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u6, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u5, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u4, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u4 * x
	if d := y.u4; d != 0 {
		c, z.u4 = mulAddWWW(x.u0, d, z.u4)
		c, z.u5 = mulAddWWWW(x.u1, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u2, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u3, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u5 * x
	if d := y.u5; d != 0 {
		c, z.u5 = mulAddWWW(x.u0, d, z.u5)
		c, z.u6 = mulAddWWWW(x.u1, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u2, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u6 * x
	if d := y.u6; d != 0 {
		c, z.u6 = mulAddWWW(x.u0, d, z.u6)
		c, z.u7 = mulAddWWWW(x.u1, d, z.u7, c)
		if c != 0 {
			return Uint512{}, false
		}
	}

	// y.u7 * x
	if d := y.u7; d != 0 {
		c, z.u7 = mulAddWWW(x.u0, d, z.u7)
		if c != 0 {
			return Uint512{}, false
		}
	}

	return z, true
}

func (x Uint512) mulCheck64(y uint64) (Uint512, bool) {
	if y == 0 {
		return Uint512{}, true
	}
	var z Uint512
	var c uint64
	c, z.u0 = bits.Mul64(x.u0, y)
	c, z.u1 = mulAddWWW(x.u1, y, c)
	c, z.u2 = mulAddWWW(x.u2, y, c)
	c, z.u3 = mulAddWWW(x.u3, y, c)
	c, z.u4 = mulAddWWW(x.u4, y, c)
	c, z.u5 = mulAddWWW(x.u5, y, c)
	c, z.u6 = mulAddWWW(x.u6, y, c)
	c, z.u7 = mulAddWWW(x.u7, y, c)
	if c != 0 {
		return Uint512{}, false
	}
	return z, true
}

// QuoRem returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint512) QuoRem(y Uint512) (q, r Uint512) {
	if x.Cmp(y) < 0 {
		// x/y for x < y = 0.
		// x%y for x < y = x.
		return Uint512{}, x
	}

	if y.high().IsZero() {
		q, rr := x.quoRem256(y.low())
		return q, u512(rr, Uint256{})
	}

	n := uint(y.high().LeadingZeros())
	y1 := y.Lsh(n) // y1 := y<<n
	x1 := x.Rsh(1) // x1 := x>>1
	tq, _ := div256(x1.high(), x1.low(), y1.high())
	tq = tq.Rsh(255 - n) // tq >>= 255 - n
	if !tq.IsZero() {
		tq = tq.sub64(1) // tq--
	}
	q = u512(tq, Uint256{})
	ytq := y.mul256(tq) // ytq := y*tq
	r = x.Sub(ytq)      // r = x-ytq
	if r.Cmp(y) >= 0 {
		q = q.add64(1) // q++
		r = r.Sub(y)   // r -= y
	}
	return
}

// quoRem256 returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint512) quoRem256(y Uint256) (q Uint512, r Uint256) {
	if x.high().Cmp(y) < 0 {
		lo, r := div256(x.high(), x.low(), y)
		return u512(lo, Uint256{}), r
	}
	hi, r := div256(Uint256{}, x.high(), y)
	lo, r := div256(r, x.low(), y)
	return u512(lo, hi), r
}

// quoRem64 returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint512) quoRem64(y uint64) (q Uint512, r uint64) {
	q.u7, r = bits.Div64(0, x.u7, y)
	q.u6, r = bits.Div64(r, x.u6, y)
	q.u5, r = bits.Div64(r, x.u5, y)
	q.u4, r = bits.Div64(r, x.u4, y)
	q.u3, r = bits.Div64(r, x.u3, y)
	q.u2, r = bits.Div64(r, x.u2, y)
	q.u1, r = bits.Div64(r, x.u1, y)
	q.u0, r = bits.Div64(r, x.u0, y)
	return q, r
}

// div512 returns (q, r) such that
//
//	q = (hi, lo)/y
//	r = (hi, lo) - y*q
func div512(hi, lo, y Uint512) (q, r Uint512) {
	if y.IsZero() {
		panic("integer divide by zero")
	}
	if y.Cmp(hi) <= 0 {
		panic("integer overflow")
	}

	s := uint(y.LeadingZeros())
	y = y.Lsh(s)    // y = y<<s
	yn1 := y.high() // yn1 := y >> 256
	yn0 := y.low()  // yn0 := y & mask256

	un32 := hi.Lsh(s).Or(lo.Rsh(512 - s)) // un32 := hi<<s | lo>>(512-s)
	un10 := lo.Lsh(s)                     // un10 := lo<<s
	un1 := un10.high()                    // un1 := un10 >> 256
	un0 := un10.low()                     // un0 := un10 & mask256
	q1, rhat := un32.quoRem256(yn1)

	var c uint64 // rhat + yn1 carry

	// for q1 >= two256 || q1*yn0 > two256*rhat+un1 { ... }
	for !q1.high().IsZero() || q1.mul256(yn0).Cmp(u512(un1, rhat)) > 0 {
		q1 = q1.sub64(1)             // q1--
		rhat, c = rhat.AddCheck(yn1) // rhat += yn1
		if c != 0 {
			break
		}
	}

	// un21 := un32*two256 + un1 - q1*y
	un21 := u512(un1, un32.low()).Sub(q1.Mul(y))
	q0, rhat := un21.quoRem256(yn1)

	// for q0 >= two256 || q0*yn0 > two256*rhat+un0 { ... }
	for !q0.high().IsZero() || q0.mul256(yn0).Cmp(u512(un0, rhat)) > 0 {
		q0 = q0.sub64(1)             // q0--
		rhat, c = rhat.AddCheck(yn1) // rhat += yn1
		if c != 0 {
			break
		}
	}

	// q = q1*two256 + q0
	q = u512(q0.low(), q1.low())
	// r = (un21*two256 + un0 - q0*y) >> s
	r = u512(un0, un21.low()).Sub(q0.Mul(y)).Rsh(s)
	return
}

func (x Uint512) GoString() string {
	return fmt.Sprintf("[%d %d %d %d %d %d %d %d]",
		x.u0,
		x.u1,
		x.u2,
		x.u3,
		x.u4,
		x.u5,
		x.u6,
		x.u7,
	)
}

// String returns the base-10 representation of x.
func (x Uint512) String() string {
	b := make([]byte, 155)
	i := len(b)
	for x.cmp64(10) >= 0 {
		q, r := x.quoRem64(10)
		i--
		b[i] = byte(r + '0')
		x = q
	}
	i--
	b[i] = byte(x.u0 + '0')
	return string(b[i:])
}

// ParseUint512 returns the value of s in the given base.
func ParseUint512(s string, base int) (Uint512, error) {
	x, _, _, err := parseUint[Uint512](s, base, false)
	return x, err
}
