// Code generated by 'gen'. DO NOT EDIT.

package fixed

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
	"sync"
)

// Uint1024 is an unsigned, 1024-bit integer.
//
// It can be compared for equality with ==.
type Uint1024 struct {
	u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15 uint64
}

var _ Uint[Uint1024] = Uint1024{}

// U1024 constructs a [Uint1024].
//
// The inputs are in ascending (low to high) order. For example,
// a uint64 x can be converted to a [Uint1024], with
//
//	U1024(x, 0, 0, ...)
//
// or more simply
//
//	U1024From64(x)
func U1024(u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15 uint64) Uint1024 {
	return Uint1024{u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15}
}

// U1024From64 constructs a [Uint1024] from a uint64.
func U1024From64(x uint64) Uint1024 {
	return Uint1024{u0: x}
}

func u1024(lo, hi Uint512) Uint1024 {
	return Uint1024{
		lo.u0,
		lo.u1,
		lo.u2,
		lo.u3,
		lo.u4,
		lo.u5,
		lo.u6,
		lo.u7,
		hi.u0,
		hi.u1,
		hi.u2,
		hi.u3,
		hi.u4,
		hi.u5,
		hi.u6,
		hi.u7,
	}
}

func (Uint1024) max() Uint1024 {
	return Uint1024{
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
		math.MaxUint64,
	}
}

func (x Uint1024) low() Uint512 {
	return Uint512{
		x.u0,
		x.u1,
		x.u2,
		x.u3,
		x.u4,
		x.u5,
		x.u6,
		x.u7}
}

func (x Uint1024) high() Uint512 {
	return Uint512{
		x.u8,
		x.u9,
		x.u10,
		x.u11,
		x.u12,
		x.u13,
		x.u14,
		x.u15}
}

func (x Uint1024) uint8() uint8 {
	return uint8(x.u0)
}

// Bytes encodes x as a little-endian integer.
func (x Uint1024) Bytes(b *[128]byte) {
	binary.LittleEndian.PutUint64(b[0:], x.u0)
	binary.LittleEndian.PutUint64(b[8:], x.u1)
	binary.LittleEndian.PutUint64(b[16:], x.u2)
	binary.LittleEndian.PutUint64(b[24:], x.u3)
	binary.LittleEndian.PutUint64(b[32:], x.u4)
	binary.LittleEndian.PutUint64(b[40:], x.u5)
	binary.LittleEndian.PutUint64(b[48:], x.u6)
	binary.LittleEndian.PutUint64(b[56:], x.u7)
	binary.LittleEndian.PutUint64(b[64:], x.u8)
	binary.LittleEndian.PutUint64(b[72:], x.u9)
	binary.LittleEndian.PutUint64(b[80:], x.u10)
	binary.LittleEndian.PutUint64(b[88:], x.u11)
	binary.LittleEndian.PutUint64(b[96:], x.u12)
	binary.LittleEndian.PutUint64(b[104:], x.u13)
	binary.LittleEndian.PutUint64(b[112:], x.u14)
	binary.LittleEndian.PutUint64(b[120:], x.u15)

}

// SetBytes sets x to the encoded little-endian integer b.
func (x *Uint1024) SetBytes(b []byte) error {
	if len(b) != 128 {
		return fmt.Errorf("fixed: invalid length: %d", len(b))
	}
	x.u0 = binary.LittleEndian.Uint64(b[0:])
	x.u1 = binary.LittleEndian.Uint64(b[8:])
	x.u2 = binary.LittleEndian.Uint64(b[16:])
	x.u3 = binary.LittleEndian.Uint64(b[24:])
	x.u4 = binary.LittleEndian.Uint64(b[32:])
	x.u5 = binary.LittleEndian.Uint64(b[40:])
	x.u6 = binary.LittleEndian.Uint64(b[48:])
	x.u7 = binary.LittleEndian.Uint64(b[56:])
	x.u8 = binary.LittleEndian.Uint64(b[64:])
	x.u9 = binary.LittleEndian.Uint64(b[72:])
	x.u10 = binary.LittleEndian.Uint64(b[80:])
	x.u11 = binary.LittleEndian.Uint64(b[88:])
	x.u12 = binary.LittleEndian.Uint64(b[96:])
	x.u13 = binary.LittleEndian.Uint64(b[104:])
	x.u14 = binary.LittleEndian.Uint64(b[112:])
	x.u15 = binary.LittleEndian.Uint64(b[120:])
	return nil
}

// Size returns the width of the integer in bits.
func (Uint1024) Size() int {
	return 1024
}

// BitLen returns the number of bits required to represent x.
func (x Uint1024) BitLen() int {
	switch {
	case x.u15 != 0:
		return 960 + bits.Len64(x.u15)
	case x.u14 != 0:
		return 896 + bits.Len64(x.u14)
	case x.u13 != 0:
		return 832 + bits.Len64(x.u13)
	case x.u12 != 0:
		return 768 + bits.Len64(x.u12)
	case x.u11 != 0:
		return 704 + bits.Len64(x.u11)
	case x.u10 != 0:
		return 640 + bits.Len64(x.u10)
	case x.u9 != 0:
		return 576 + bits.Len64(x.u9)
	case x.u8 != 0:
		return 512 + bits.Len64(x.u8)
	case x.u7 != 0:
		return 448 + bits.Len64(x.u7)
	case x.u6 != 0:
		return 384 + bits.Len64(x.u6)
	case x.u5 != 0:
		return 320 + bits.Len64(x.u5)
	case x.u4 != 0:
		return 256 + bits.Len64(x.u4)
	case x.u3 != 0:
		return 192 + bits.Len64(x.u3)
	case x.u2 != 0:
		return 128 + bits.Len64(x.u2)
	case x.u1 != 0:
		return 64 + bits.Len64(x.u1)
	default:
		return bits.Len64(x.u0)
	}
}

// LeadingZeros returns the number of leading zeros in x.
func (x Uint1024) LeadingZeros() int {
	return 1024 - x.BitLen()
}

// IsZero is shorthand for x == Uint1024{}.
func (x Uint1024) IsZero() bool {
	return x == Uint1024{}
}

// Cmp compares x and y and returns
//
//   - +1 if x > y
//   - 0 if x == y
//   - -1 if x < y
func (x Uint1024) Cmp(y Uint1024) int {
	switch {
	case x.u15 != y.u15:
		return cmp(x.u15, y.u15)
	case x.u14 != y.u14:
		return cmp(x.u14, y.u14)
	case x.u13 != y.u13:
		return cmp(x.u13, y.u13)
	case x.u12 != y.u12:
		return cmp(x.u12, y.u12)
	case x.u11 != y.u11:
		return cmp(x.u11, y.u11)
	case x.u10 != y.u10:
		return cmp(x.u10, y.u10)
	case x.u9 != y.u9:
		return cmp(x.u9, y.u9)
	case x.u8 != y.u8:
		return cmp(x.u8, y.u8)
	case x.u7 != y.u7:
		return cmp(x.u7, y.u7)
	case x.u6 != y.u6:
		return cmp(x.u6, y.u6)
	case x.u5 != y.u5:
		return cmp(x.u5, y.u5)
	case x.u4 != y.u4:
		return cmp(x.u4, y.u4)
	case x.u3 != y.u3:
		return cmp(x.u3, y.u3)
	case x.u2 != y.u2:
		return cmp(x.u2, y.u2)
	case x.u1 != y.u1:
		return cmp(x.u1, y.u1)
	default:
		return cmp(x.u0, y.u0)
	}
}

// cmp64 compares x and y and returns
//
//   - +1 if x > y
//   - 0 if x == y
//   - -1 if x < y
func (x Uint1024) cmp64(y uint64) int {
	v := x
	v.u0 = 0
	if !v.IsZero() {
		return +1
	}
	return cmp(x.u0, y)
}

// Equal reports whether x == y.
//
// In general, prefer the == operator to using this method.
func (x Uint1024) Equal(y Uint1024) bool {
	return x == y
}

// And returns x&y.
func (x Uint1024) And(y Uint1024) Uint1024 {
	return Uint1024{
		x.u0 & y.u0,
		x.u1 & y.u1,
		x.u2 & y.u2,
		x.u3 & y.u3,
		x.u4 & y.u4,
		x.u5 & y.u5,
		x.u6 & y.u6,
		x.u7 & y.u7,
		x.u8 & y.u8,
		x.u9 & y.u9,
		x.u10 & y.u10,
		x.u11 & y.u11,
		x.u12 & y.u12,
		x.u13 & y.u13,
		x.u14 & y.u14,
		x.u15 & y.u15,
	}
}

// Or returns x|y.
func (x Uint1024) Or(y Uint1024) Uint1024 {
	return Uint1024{
		x.u0 | y.u0,
		x.u1 | y.u1,
		x.u2 | y.u2,
		x.u3 | y.u3,
		x.u4 | y.u4,
		x.u5 | y.u5,
		x.u6 | y.u6,
		x.u7 | y.u7,
		x.u8 | y.u8,
		x.u9 | y.u9,
		x.u10 | y.u10,
		x.u11 | y.u11,
		x.u12 | y.u12,
		x.u13 | y.u13,
		x.u14 | y.u14,
		x.u15 | y.u15,
	}
}

// orLsh64 returns x | y<<s.
func (x Uint1024) orLsh64(y uint64, s uint) Uint1024 {
	return x.Or(Uint1024{u0: y}.Lsh(s))
}

// Xor returns x^y.
func (x Uint1024) Xor(y Uint1024) Uint1024 {
	return Uint1024{
		x.u0 ^ y.u0,
		x.u1 ^ y.u1,
		x.u2 ^ y.u2,
		x.u3 ^ y.u3,
		x.u4 ^ y.u4,
		x.u5 ^ y.u5,
		x.u6 ^ y.u6,
		x.u7 ^ y.u7,
		x.u8 ^ y.u8,
		x.u9 ^ y.u9,
		x.u10 ^ y.u10,
		x.u11 ^ y.u11,
		x.u12 ^ y.u12,
		x.u13 ^ y.u13,
		x.u14 ^ y.u14,
		x.u15 ^ y.u15,
	}
}

// Lsh returns x<<n.
func (x Uint1024) Lsh(n uint) Uint1024 {
	switch {
	case n > 960:
		s := n - 960
		return Uint1024{
			u15: x.u0 << s,
		}
	case n > 896:
		s := n - 896
		ŝ := 64 - s
		return Uint1024{
			u14: x.u0 << s,
			u15: x.u1<<s | x.u0>>ŝ,
		}
	case n > 832:
		s := n - 832
		ŝ := 64 - s
		return Uint1024{
			u13: x.u0 << s,
			u14: x.u1<<s | x.u0>>ŝ,
			u15: x.u2<<s | x.u1>>ŝ,
		}
	case n > 768:
		s := n - 768
		ŝ := 64 - s
		return Uint1024{
			u12: x.u0 << s,
			u13: x.u1<<s | x.u0>>ŝ,
			u14: x.u2<<s | x.u1>>ŝ,
			u15: x.u3<<s | x.u2>>ŝ,
		}
	case n > 704:
		s := n - 704
		ŝ := 64 - s
		return Uint1024{
			u11: x.u0 << s,
			u12: x.u1<<s | x.u0>>ŝ,
			u13: x.u2<<s | x.u1>>ŝ,
			u14: x.u3<<s | x.u2>>ŝ,
			u15: x.u4<<s | x.u3>>ŝ,
		}
	case n > 640:
		s := n - 640
		ŝ := 64 - s
		return Uint1024{
			u10: x.u0 << s,
			u11: x.u1<<s | x.u0>>ŝ,
			u12: x.u2<<s | x.u1>>ŝ,
			u13: x.u3<<s | x.u2>>ŝ,
			u14: x.u4<<s | x.u3>>ŝ,
			u15: x.u5<<s | x.u4>>ŝ,
		}
	case n > 576:
		s := n - 576
		ŝ := 64 - s
		return Uint1024{
			u9:  x.u0 << s,
			u10: x.u1<<s | x.u0>>ŝ,
			u11: x.u2<<s | x.u1>>ŝ,
			u12: x.u3<<s | x.u2>>ŝ,
			u13: x.u4<<s | x.u3>>ŝ,
			u14: x.u5<<s | x.u4>>ŝ,
			u15: x.u6<<s | x.u5>>ŝ,
		}
	case n > 512:
		s := n - 512
		ŝ := 64 - s
		return Uint1024{
			u8:  x.u0 << s,
			u9:  x.u1<<s | x.u0>>ŝ,
			u10: x.u2<<s | x.u1>>ŝ,
			u11: x.u3<<s | x.u2>>ŝ,
			u12: x.u4<<s | x.u3>>ŝ,
			u13: x.u5<<s | x.u4>>ŝ,
			u14: x.u6<<s | x.u5>>ŝ,
			u15: x.u7<<s | x.u6>>ŝ,
		}
	case n > 448:
		s := n - 448
		ŝ := 64 - s
		return Uint1024{
			u7:  x.u0 << s,
			u8:  x.u1<<s | x.u0>>ŝ,
			u9:  x.u2<<s | x.u1>>ŝ,
			u10: x.u3<<s | x.u2>>ŝ,
			u11: x.u4<<s | x.u3>>ŝ,
			u12: x.u5<<s | x.u4>>ŝ,
			u13: x.u6<<s | x.u5>>ŝ,
			u14: x.u7<<s | x.u6>>ŝ,
			u15: x.u8<<s | x.u7>>ŝ,
		}
	case n > 384:
		s := n - 384
		ŝ := 64 - s
		return Uint1024{
			u6:  x.u0 << s,
			u7:  x.u1<<s | x.u0>>ŝ,
			u8:  x.u2<<s | x.u1>>ŝ,
			u9:  x.u3<<s | x.u2>>ŝ,
			u10: x.u4<<s | x.u3>>ŝ,
			u11: x.u5<<s | x.u4>>ŝ,
			u12: x.u6<<s | x.u5>>ŝ,
			u13: x.u7<<s | x.u6>>ŝ,
			u14: x.u8<<s | x.u7>>ŝ,
			u15: x.u9<<s | x.u8>>ŝ,
		}
	case n > 320:
		s := n - 320
		ŝ := 64 - s
		return Uint1024{
			u5:  x.u0 << s,
			u6:  x.u1<<s | x.u0>>ŝ,
			u7:  x.u2<<s | x.u1>>ŝ,
			u8:  x.u3<<s | x.u2>>ŝ,
			u9:  x.u4<<s | x.u3>>ŝ,
			u10: x.u5<<s | x.u4>>ŝ,
			u11: x.u6<<s | x.u5>>ŝ,
			u12: x.u7<<s | x.u6>>ŝ,
			u13: x.u8<<s | x.u7>>ŝ,
			u14: x.u9<<s | x.u8>>ŝ,
			u15: x.u10<<s | x.u9>>ŝ,
		}
	case n > 256:
		s := n - 256
		ŝ := 64 - s
		return Uint1024{
			u4:  x.u0 << s,
			u5:  x.u1<<s | x.u0>>ŝ,
			u6:  x.u2<<s | x.u1>>ŝ,
			u7:  x.u3<<s | x.u2>>ŝ,
			u8:  x.u4<<s | x.u3>>ŝ,
			u9:  x.u5<<s | x.u4>>ŝ,
			u10: x.u6<<s | x.u5>>ŝ,
			u11: x.u7<<s | x.u6>>ŝ,
			u12: x.u8<<s | x.u7>>ŝ,
			u13: x.u9<<s | x.u8>>ŝ,
			u14: x.u10<<s | x.u9>>ŝ,
			u15: x.u11<<s | x.u10>>ŝ,
		}
	case n > 192:
		s := n - 192
		ŝ := 64 - s
		return Uint1024{
			u3:  x.u0 << s,
			u4:  x.u1<<s | x.u0>>ŝ,
			u5:  x.u2<<s | x.u1>>ŝ,
			u6:  x.u3<<s | x.u2>>ŝ,
			u7:  x.u4<<s | x.u3>>ŝ,
			u8:  x.u5<<s | x.u4>>ŝ,
			u9:  x.u6<<s | x.u5>>ŝ,
			u10: x.u7<<s | x.u6>>ŝ,
			u11: x.u8<<s | x.u7>>ŝ,
			u12: x.u9<<s | x.u8>>ŝ,
			u13: x.u10<<s | x.u9>>ŝ,
			u14: x.u11<<s | x.u10>>ŝ,
			u15: x.u12<<s | x.u11>>ŝ,
		}
	case n > 128:
		s := n - 128
		ŝ := 64 - s
		return Uint1024{
			u2:  x.u0 << s,
			u3:  x.u1<<s | x.u0>>ŝ,
			u4:  x.u2<<s | x.u1>>ŝ,
			u5:  x.u3<<s | x.u2>>ŝ,
			u6:  x.u4<<s | x.u3>>ŝ,
			u7:  x.u5<<s | x.u4>>ŝ,
			u8:  x.u6<<s | x.u5>>ŝ,
			u9:  x.u7<<s | x.u6>>ŝ,
			u10: x.u8<<s | x.u7>>ŝ,
			u11: x.u9<<s | x.u8>>ŝ,
			u12: x.u10<<s | x.u9>>ŝ,
			u13: x.u11<<s | x.u10>>ŝ,
			u14: x.u12<<s | x.u11>>ŝ,
			u15: x.u13<<s | x.u12>>ŝ,
		}
	case n > 64:
		s := n - 64
		ŝ := 64 - s
		return Uint1024{
			u1:  x.u0 << s,
			u2:  x.u1<<s | x.u0>>ŝ,
			u3:  x.u2<<s | x.u1>>ŝ,
			u4:  x.u3<<s | x.u2>>ŝ,
			u5:  x.u4<<s | x.u3>>ŝ,
			u6:  x.u5<<s | x.u4>>ŝ,
			u7:  x.u6<<s | x.u5>>ŝ,
			u8:  x.u7<<s | x.u6>>ŝ,
			u9:  x.u8<<s | x.u7>>ŝ,
			u10: x.u9<<s | x.u8>>ŝ,
			u11: x.u10<<s | x.u9>>ŝ,
			u12: x.u11<<s | x.u10>>ŝ,
			u13: x.u12<<s | x.u11>>ŝ,
			u14: x.u13<<s | x.u12>>ŝ,
			u15: x.u14<<s | x.u13>>ŝ,
		}
	default:
		s := n
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u0 << s,
			u1:  x.u1<<s | x.u0>>ŝ,
			u2:  x.u2<<s | x.u1>>ŝ,
			u3:  x.u3<<s | x.u2>>ŝ,
			u4:  x.u4<<s | x.u3>>ŝ,
			u5:  x.u5<<s | x.u4>>ŝ,
			u6:  x.u6<<s | x.u5>>ŝ,
			u7:  x.u7<<s | x.u6>>ŝ,
			u8:  x.u8<<s | x.u7>>ŝ,
			u9:  x.u9<<s | x.u8>>ŝ,
			u10: x.u10<<s | x.u9>>ŝ,
			u11: x.u11<<s | x.u10>>ŝ,
			u12: x.u12<<s | x.u11>>ŝ,
			u13: x.u13<<s | x.u12>>ŝ,
			u14: x.u14<<s | x.u13>>ŝ,
			u15: x.u15<<s | x.u14>>ŝ,
		}
	}
}

// Rsh returns x>>n.
func (x Uint1024) Rsh(n uint) Uint1024 {
	switch {
	case n > 960:
		s := n - 960
		return Uint1024{
			u0: x.u15 >> s,
		}
	case n > 896:
		s := n - 896
		ŝ := 64 - s
		return Uint1024{
			u0: x.u14>>s | x.u15<<ŝ,
			u1: x.u15 >> s,
		}
	case n > 832:
		s := n - 832
		ŝ := 64 - s
		return Uint1024{
			u0: x.u13>>s | x.u14<<ŝ,
			u1: x.u14>>s | x.u15<<ŝ,
			u2: x.u15 >> s,
		}
	case n > 768:
		s := n - 768
		ŝ := 64 - s
		return Uint1024{
			u0: x.u12>>s | x.u13<<ŝ,
			u1: x.u13>>s | x.u14<<ŝ,
			u2: x.u14>>s | x.u15<<ŝ,
			u3: x.u15 >> s,
		}
	case n > 704:
		s := n - 704
		ŝ := 64 - s
		return Uint1024{
			u0: x.u11>>s | x.u12<<ŝ,
			u1: x.u12>>s | x.u13<<ŝ,
			u2: x.u13>>s | x.u14<<ŝ,
			u3: x.u14>>s | x.u15<<ŝ,
			u4: x.u15 >> s,
		}
	case n > 640:
		s := n - 640
		ŝ := 64 - s
		return Uint1024{
			u0: x.u10>>s | x.u11<<ŝ,
			u1: x.u11>>s | x.u12<<ŝ,
			u2: x.u12>>s | x.u13<<ŝ,
			u3: x.u13>>s | x.u14<<ŝ,
			u4: x.u14>>s | x.u15<<ŝ,
			u5: x.u15 >> s,
		}
	case n > 576:
		s := n - 576
		ŝ := 64 - s
		return Uint1024{
			u0: x.u9>>s | x.u10<<ŝ,
			u1: x.u10>>s | x.u11<<ŝ,
			u2: x.u11>>s | x.u12<<ŝ,
			u3: x.u12>>s | x.u13<<ŝ,
			u4: x.u13>>s | x.u14<<ŝ,
			u5: x.u14>>s | x.u15<<ŝ,
			u6: x.u15 >> s,
		}
	case n > 512:
		s := n - 512
		ŝ := 64 - s
		return Uint1024{
			u0: x.u8>>s | x.u9<<ŝ,
			u1: x.u9>>s | x.u10<<ŝ,
			u2: x.u10>>s | x.u11<<ŝ,
			u3: x.u11>>s | x.u12<<ŝ,
			u4: x.u12>>s | x.u13<<ŝ,
			u5: x.u13>>s | x.u14<<ŝ,
			u6: x.u14>>s | x.u15<<ŝ,
			u7: x.u15 >> s,
		}
	case n > 448:
		s := n - 448
		ŝ := 64 - s
		return Uint1024{
			u0: x.u7>>s | x.u8<<ŝ,
			u1: x.u8>>s | x.u9<<ŝ,
			u2: x.u9>>s | x.u10<<ŝ,
			u3: x.u10>>s | x.u11<<ŝ,
			u4: x.u11>>s | x.u12<<ŝ,
			u5: x.u12>>s | x.u13<<ŝ,
			u6: x.u13>>s | x.u14<<ŝ,
			u7: x.u14>>s | x.u15<<ŝ,
			u8: x.u15 >> s,
		}
	case n > 384:
		s := n - 384
		ŝ := 64 - s
		return Uint1024{
			u0: x.u6>>s | x.u7<<ŝ,
			u1: x.u7>>s | x.u8<<ŝ,
			u2: x.u8>>s | x.u9<<ŝ,
			u3: x.u9>>s | x.u10<<ŝ,
			u4: x.u10>>s | x.u11<<ŝ,
			u5: x.u11>>s | x.u12<<ŝ,
			u6: x.u12>>s | x.u13<<ŝ,
			u7: x.u13>>s | x.u14<<ŝ,
			u8: x.u14>>s | x.u15<<ŝ,
			u9: x.u15 >> s,
		}
	case n > 320:
		s := n - 320
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u5>>s | x.u6<<ŝ,
			u1:  x.u6>>s | x.u7<<ŝ,
			u2:  x.u7>>s | x.u8<<ŝ,
			u3:  x.u8>>s | x.u9<<ŝ,
			u4:  x.u9>>s | x.u10<<ŝ,
			u5:  x.u10>>s | x.u11<<ŝ,
			u6:  x.u11>>s | x.u12<<ŝ,
			u7:  x.u12>>s | x.u13<<ŝ,
			u8:  x.u13>>s | x.u14<<ŝ,
			u9:  x.u14>>s | x.u15<<ŝ,
			u10: x.u15 >> s,
		}
	case n > 256:
		s := n - 256
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u4>>s | x.u5<<ŝ,
			u1:  x.u5>>s | x.u6<<ŝ,
			u2:  x.u6>>s | x.u7<<ŝ,
			u3:  x.u7>>s | x.u8<<ŝ,
			u4:  x.u8>>s | x.u9<<ŝ,
			u5:  x.u9>>s | x.u10<<ŝ,
			u6:  x.u10>>s | x.u11<<ŝ,
			u7:  x.u11>>s | x.u12<<ŝ,
			u8:  x.u12>>s | x.u13<<ŝ,
			u9:  x.u13>>s | x.u14<<ŝ,
			u10: x.u14>>s | x.u15<<ŝ,
			u11: x.u15 >> s,
		}
	case n > 192:
		s := n - 192
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u3>>s | x.u4<<ŝ,
			u1:  x.u4>>s | x.u5<<ŝ,
			u2:  x.u5>>s | x.u6<<ŝ,
			u3:  x.u6>>s | x.u7<<ŝ,
			u4:  x.u7>>s | x.u8<<ŝ,
			u5:  x.u8>>s | x.u9<<ŝ,
			u6:  x.u9>>s | x.u10<<ŝ,
			u7:  x.u10>>s | x.u11<<ŝ,
			u8:  x.u11>>s | x.u12<<ŝ,
			u9:  x.u12>>s | x.u13<<ŝ,
			u10: x.u13>>s | x.u14<<ŝ,
			u11: x.u14>>s | x.u15<<ŝ,
			u12: x.u15 >> s,
		}
	case n > 128:
		s := n - 128
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u2>>s | x.u3<<ŝ,
			u1:  x.u3>>s | x.u4<<ŝ,
			u2:  x.u4>>s | x.u5<<ŝ,
			u3:  x.u5>>s | x.u6<<ŝ,
			u4:  x.u6>>s | x.u7<<ŝ,
			u5:  x.u7>>s | x.u8<<ŝ,
			u6:  x.u8>>s | x.u9<<ŝ,
			u7:  x.u9>>s | x.u10<<ŝ,
			u8:  x.u10>>s | x.u11<<ŝ,
			u9:  x.u11>>s | x.u12<<ŝ,
			u10: x.u12>>s | x.u13<<ŝ,
			u11: x.u13>>s | x.u14<<ŝ,
			u12: x.u14>>s | x.u15<<ŝ,
			u13: x.u15 >> s,
		}
	case n > 64:
		s := n - 64
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u1>>s | x.u2<<ŝ,
			u1:  x.u2>>s | x.u3<<ŝ,
			u2:  x.u3>>s | x.u4<<ŝ,
			u3:  x.u4>>s | x.u5<<ŝ,
			u4:  x.u5>>s | x.u6<<ŝ,
			u5:  x.u6>>s | x.u7<<ŝ,
			u6:  x.u7>>s | x.u8<<ŝ,
			u7:  x.u8>>s | x.u9<<ŝ,
			u8:  x.u9>>s | x.u10<<ŝ,
			u9:  x.u10>>s | x.u11<<ŝ,
			u10: x.u11>>s | x.u12<<ŝ,
			u11: x.u12>>s | x.u13<<ŝ,
			u12: x.u13>>s | x.u14<<ŝ,
			u13: x.u14>>s | x.u15<<ŝ,
			u14: x.u15 >> s,
		}
	default:
		s := n
		ŝ := 64 - s
		return Uint1024{
			u0:  x.u0>>s | x.u1<<ŝ,
			u1:  x.u1>>s | x.u2<<ŝ,
			u2:  x.u2>>s | x.u3<<ŝ,
			u3:  x.u3>>s | x.u4<<ŝ,
			u4:  x.u4>>s | x.u5<<ŝ,
			u5:  x.u5>>s | x.u6<<ŝ,
			u6:  x.u6>>s | x.u7<<ŝ,
			u7:  x.u7>>s | x.u8<<ŝ,
			u8:  x.u8>>s | x.u9<<ŝ,
			u9:  x.u9>>s | x.u10<<ŝ,
			u10: x.u10>>s | x.u11<<ŝ,
			u11: x.u11>>s | x.u12<<ŝ,
			u12: x.u12>>s | x.u13<<ŝ,
			u13: x.u13>>s | x.u14<<ŝ,
			u14: x.u14>>s | x.u15<<ŝ,
			u15: x.u15 >> s,
		}
	}
}

// Add returns x+y.
func (x Uint1024) Add(y Uint1024) Uint1024 {
	var z Uint1024
	var carry uint64
	z.u0, carry = bits.Add64(x.u0, y.u0, 0)
	z.u1, carry = bits.Add64(x.u1, y.u1, carry)
	z.u2, carry = bits.Add64(x.u2, y.u2, carry)
	z.u3, carry = bits.Add64(x.u3, y.u3, carry)
	z.u4, carry = bits.Add64(x.u4, y.u4, carry)
	z.u5, carry = bits.Add64(x.u5, y.u5, carry)
	z.u6, carry = bits.Add64(x.u6, y.u6, carry)
	z.u7, carry = bits.Add64(x.u7, y.u7, carry)
	z.u8, carry = bits.Add64(x.u8, y.u8, carry)
	z.u9, carry = bits.Add64(x.u9, y.u9, carry)
	z.u10, carry = bits.Add64(x.u10, y.u10, carry)
	z.u11, carry = bits.Add64(x.u11, y.u11, carry)
	z.u12, carry = bits.Add64(x.u12, y.u12, carry)
	z.u13, carry = bits.Add64(x.u13, y.u13, carry)
	z.u14, carry = bits.Add64(x.u14, y.u14, carry)
	z.u15, _ = bits.Add64(x.u15, y.u15, carry)
	return z
}

// add64 returns x+y.
func (x Uint1024) add64(y uint64) Uint1024 {
	var z Uint1024
	var carry uint64
	z.u0, carry = bits.Add64(x.u0, y, 0)
	z.u1, carry = bits.Add64(x.u1, 0, carry)
	z.u2, carry = bits.Add64(x.u2, 0, carry)
	z.u3, carry = bits.Add64(x.u3, 0, carry)
	z.u4, carry = bits.Add64(x.u4, 0, carry)
	z.u5, carry = bits.Add64(x.u5, 0, carry)
	z.u6, carry = bits.Add64(x.u6, 0, carry)
	z.u7, carry = bits.Add64(x.u7, 0, carry)
	z.u8, carry = bits.Add64(x.u8, 0, carry)
	z.u9, carry = bits.Add64(x.u9, 0, carry)
	z.u10, carry = bits.Add64(x.u10, 0, carry)
	z.u11, carry = bits.Add64(x.u11, 0, carry)
	z.u12, carry = bits.Add64(x.u12, 0, carry)
	z.u13, carry = bits.Add64(x.u13, 0, carry)
	z.u14, carry = bits.Add64(x.u14, 0, carry)
	z.u15, _ = bits.Add64(x.u15, 0, carry)
	return z
}

// AddCheck returns x+y.
//
// carry is 1 if x+y overflows and 0 otherwise.
func (x Uint1024) AddCheck(y Uint1024) (z Uint1024, carry uint64) {
	z.u0, carry = bits.Add64(x.u0, y.u0, 0)
	z.u1, carry = bits.Add64(x.u1, y.u1, carry)
	z.u2, carry = bits.Add64(x.u2, y.u2, carry)
	z.u3, carry = bits.Add64(x.u3, y.u3, carry)
	z.u4, carry = bits.Add64(x.u4, y.u4, carry)
	z.u5, carry = bits.Add64(x.u5, y.u5, carry)
	z.u6, carry = bits.Add64(x.u6, y.u6, carry)
	z.u7, carry = bits.Add64(x.u7, y.u7, carry)
	z.u8, carry = bits.Add64(x.u8, y.u8, carry)
	z.u9, carry = bits.Add64(x.u9, y.u9, carry)
	z.u10, carry = bits.Add64(x.u10, y.u10, carry)
	z.u11, carry = bits.Add64(x.u11, y.u11, carry)
	z.u12, carry = bits.Add64(x.u12, y.u12, carry)
	z.u13, carry = bits.Add64(x.u13, y.u13, carry)
	z.u14, carry = bits.Add64(x.u14, y.u14, carry)
	z.u15, carry = bits.Add64(x.u15, y.u15, carry)
	return z, carry
}

// addCheck64 returns x+y.
//
// carry is 1 if x+y overflows and 0 otherwise.
func (x Uint1024) addCheck64(y uint64) (z Uint1024, carry uint64) {
	z.u0, carry = bits.Add64(x.u0, y, 0)
	z.u1, carry = bits.Add64(x.u1, 0, carry)
	z.u2, carry = bits.Add64(x.u2, 0, carry)
	z.u3, carry = bits.Add64(x.u3, 0, carry)
	z.u4, carry = bits.Add64(x.u4, 0, carry)
	z.u5, carry = bits.Add64(x.u5, 0, carry)
	z.u6, carry = bits.Add64(x.u6, 0, carry)
	z.u7, carry = bits.Add64(x.u7, 0, carry)
	z.u8, carry = bits.Add64(x.u8, 0, carry)
	z.u9, carry = bits.Add64(x.u9, 0, carry)
	z.u10, carry = bits.Add64(x.u10, 0, carry)
	z.u11, carry = bits.Add64(x.u11, 0, carry)
	z.u12, carry = bits.Add64(x.u12, 0, carry)
	z.u13, carry = bits.Add64(x.u13, 0, carry)
	z.u14, carry = bits.Add64(x.u14, 0, carry)
	z.u15, carry = bits.Add64(x.u15, 0, carry)
	return z, carry
}

// Sub returns x-y.
func (x Uint1024) Sub(y Uint1024) Uint1024 {
	var z Uint1024
	var borrow uint64
	z.u0, borrow = bits.Sub64(x.u0, y.u0, 0)
	z.u1, borrow = bits.Sub64(x.u1, y.u1, borrow)
	z.u2, borrow = bits.Sub64(x.u2, y.u2, borrow)
	z.u3, borrow = bits.Sub64(x.u3, y.u3, borrow)
	z.u4, borrow = bits.Sub64(x.u4, y.u4, borrow)
	z.u5, borrow = bits.Sub64(x.u5, y.u5, borrow)
	z.u6, borrow = bits.Sub64(x.u6, y.u6, borrow)
	z.u7, borrow = bits.Sub64(x.u7, y.u7, borrow)
	z.u8, borrow = bits.Sub64(x.u8, y.u8, borrow)
	z.u9, borrow = bits.Sub64(x.u9, y.u9, borrow)
	z.u10, borrow = bits.Sub64(x.u10, y.u10, borrow)
	z.u11, borrow = bits.Sub64(x.u11, y.u11, borrow)
	z.u12, borrow = bits.Sub64(x.u12, y.u12, borrow)
	z.u13, borrow = bits.Sub64(x.u13, y.u13, borrow)
	z.u14, borrow = bits.Sub64(x.u14, y.u14, borrow)
	z.u15, _ = bits.Sub64(x.u15, y.u15, borrow)
	return z
}

// sub64 returns x-y.
func (x Uint1024) sub64(y uint64) Uint1024 {
	var z Uint1024
	var borrow uint64
	z.u0, borrow = bits.Sub64(x.u0, y, 0)
	z.u1, borrow = bits.Sub64(x.u1, 0, borrow)
	z.u2, borrow = bits.Sub64(x.u2, 0, borrow)
	z.u3, borrow = bits.Sub64(x.u3, 0, borrow)
	z.u4, borrow = bits.Sub64(x.u4, 0, borrow)
	z.u5, borrow = bits.Sub64(x.u5, 0, borrow)
	z.u6, borrow = bits.Sub64(x.u6, 0, borrow)
	z.u7, borrow = bits.Sub64(x.u7, 0, borrow)
	z.u8, borrow = bits.Sub64(x.u8, 0, borrow)
	z.u9, borrow = bits.Sub64(x.u9, 0, borrow)
	z.u10, borrow = bits.Sub64(x.u10, 0, borrow)
	z.u11, borrow = bits.Sub64(x.u11, 0, borrow)
	z.u12, borrow = bits.Sub64(x.u12, 0, borrow)
	z.u13, borrow = bits.Sub64(x.u13, 0, borrow)
	z.u14, borrow = bits.Sub64(x.u14, 0, borrow)
	z.u15, _ = bits.Sub64(x.u15, 0, borrow)
	return z
}

// SubCheck returns x-y.
//
// borrow is 1 if x-y overflows and 0 otherwise.
func (x Uint1024) SubCheck(y Uint1024) (z Uint1024, borrow uint64) {
	z.u0, borrow = bits.Sub64(x.u0, y.u0, 0)
	z.u1, borrow = bits.Sub64(x.u1, y.u1, borrow)
	z.u2, borrow = bits.Sub64(x.u2, y.u2, borrow)
	z.u3, borrow = bits.Sub64(x.u3, y.u3, borrow)
	z.u4, borrow = bits.Sub64(x.u4, y.u4, borrow)
	z.u5, borrow = bits.Sub64(x.u5, y.u5, borrow)
	z.u6, borrow = bits.Sub64(x.u6, y.u6, borrow)
	z.u7, borrow = bits.Sub64(x.u7, y.u7, borrow)
	z.u8, borrow = bits.Sub64(x.u8, y.u8, borrow)
	z.u9, borrow = bits.Sub64(x.u9, y.u9, borrow)
	z.u10, borrow = bits.Sub64(x.u10, y.u10, borrow)
	z.u11, borrow = bits.Sub64(x.u11, y.u11, borrow)
	z.u12, borrow = bits.Sub64(x.u12, y.u12, borrow)
	z.u13, borrow = bits.Sub64(x.u13, y.u13, borrow)
	z.u14, borrow = bits.Sub64(x.u14, y.u14, borrow)
	z.u15, borrow = bits.Sub64(x.u15, y.u15, borrow)
	return z, borrow
}

// subCheck64 returns x-y.
//
// borrow is 1 if x-y overflows and 0 otherwise.
func (x Uint1024) subCheck64(y uint64) (z Uint1024, borrow uint64) {
	z.u0, borrow = bits.Sub64(x.u0, y, 0)
	z.u1, borrow = bits.Sub64(x.u1, 0, borrow)
	z.u2, borrow = bits.Sub64(x.u2, 0, borrow)
	z.u3, borrow = bits.Sub64(x.u3, 0, borrow)
	z.u4, borrow = bits.Sub64(x.u4, 0, borrow)
	z.u5, borrow = bits.Sub64(x.u5, 0, borrow)
	z.u6, borrow = bits.Sub64(x.u6, 0, borrow)
	z.u7, borrow = bits.Sub64(x.u7, 0, borrow)
	z.u8, borrow = bits.Sub64(x.u8, 0, borrow)
	z.u9, borrow = bits.Sub64(x.u9, 0, borrow)
	z.u10, borrow = bits.Sub64(x.u10, 0, borrow)
	z.u11, borrow = bits.Sub64(x.u11, 0, borrow)
	z.u12, borrow = bits.Sub64(x.u12, 0, borrow)
	z.u13, borrow = bits.Sub64(x.u13, 0, borrow)
	z.u14, borrow = bits.Sub64(x.u14, 0, borrow)
	z.u15, borrow = bits.Sub64(x.u15, 0, borrow)
	return z, borrow
}

// Mul returns x*y.
func (x Uint1024) Mul(y Uint1024) Uint1024 {
	var z Uint1024
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		c, z.u7 = mulAddWWW(x.u7, d, c)
		c, z.u8 = mulAddWWW(x.u8, d, c)
		c, z.u9 = mulAddWWW(x.u9, d, c)
		c, z.u10 = mulAddWWW(x.u10, d, c)
		c, z.u11 = mulAddWWW(x.u11, d, c)
		c, z.u12 = mulAddWWW(x.u12, d, c)
		c, z.u13 = mulAddWWW(x.u13, d, c)
		c, z.u14 = mulAddWWW(x.u14, d, c)
		z.u15 += x.u15*d + c
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u6, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u7, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u8, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u9, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u10, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u11, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u12, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u13, d, z.u14, c)
		z.u15 += x.u14*d + c
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u5, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u6, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u7, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u8, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u9, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u10, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u11, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u12, d, z.u14, c)
		z.u15 += x.u13*d + c
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u4, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u5, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u6, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u7, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u8, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u9, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u10, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u11, d, z.u14, c)
		z.u15 += x.u12*d + c
	}

	// y.u4 * x
	if d := y.u4; d != 0 {
		c, z.u4 = mulAddWWW(x.u0, d, z.u4)
		c, z.u5 = mulAddWWWW(x.u1, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u2, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u3, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u4, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u5, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u6, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u7, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u8, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u9, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u10, d, z.u14, c)
		z.u15 += x.u11*d + c
	}

	// y.u5 * x
	if d := y.u5; d != 0 {
		c, z.u5 = mulAddWWW(x.u0, d, z.u5)
		c, z.u6 = mulAddWWWW(x.u1, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u2, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u3, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u4, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u5, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u6, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u7, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u8, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u9, d, z.u14, c)
		z.u15 += x.u10*d + c
	}

	// y.u6 * x
	if d := y.u6; d != 0 {
		c, z.u6 = mulAddWWW(x.u0, d, z.u6)
		c, z.u7 = mulAddWWWW(x.u1, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u2, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u3, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u4, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u5, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u6, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u7, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u8, d, z.u14, c)
		z.u15 += x.u9*d + c
	}

	// y.u7 * x
	if d := y.u7; d != 0 {
		c, z.u7 = mulAddWWW(x.u0, d, z.u7)
		c, z.u8 = mulAddWWWW(x.u1, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u2, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u3, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u4, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u5, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u6, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u7, d, z.u14, c)
		z.u15 += x.u8*d + c
	}

	// y.u8 * x
	if d := y.u8; d != 0 {
		c, z.u8 = mulAddWWW(x.u0, d, z.u8)
		c, z.u9 = mulAddWWWW(x.u1, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u2, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u3, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u4, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u5, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u6, d, z.u14, c)
		z.u15 += x.u7*d + c
	}

	// y.u9 * x
	if d := y.u9; d != 0 {
		c, z.u9 = mulAddWWW(x.u0, d, z.u9)
		c, z.u10 = mulAddWWWW(x.u1, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u2, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u3, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u4, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u5, d, z.u14, c)
		z.u15 += x.u6*d + c
	}

	// y.u10 * x
	if d := y.u10; d != 0 {
		c, z.u10 = mulAddWWW(x.u0, d, z.u10)
		c, z.u11 = mulAddWWWW(x.u1, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u2, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u3, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u4, d, z.u14, c)
		z.u15 += x.u5*d + c
	}

	// y.u11 * x
	if d := y.u11; d != 0 {
		c, z.u11 = mulAddWWW(x.u0, d, z.u11)
		c, z.u12 = mulAddWWWW(x.u1, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u2, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u3, d, z.u14, c)
		z.u15 += x.u4*d + c
	}

	// y.u12 * x
	if d := y.u12; d != 0 {
		c, z.u12 = mulAddWWW(x.u0, d, z.u12)
		c, z.u13 = mulAddWWWW(x.u1, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u2, d, z.u14, c)
		z.u15 += x.u3*d + c
	}

	// y.u13 * x
	if d := y.u13; d != 0 {
		c, z.u13 = mulAddWWW(x.u0, d, z.u13)
		c, z.u14 = mulAddWWWW(x.u1, d, z.u14, c)
		z.u15 += x.u2*d + c
	}

	// y.u14 * x
	if d := y.u14; d != 0 {
		c, z.u14 = mulAddWWW(x.u0, d, z.u14)
		z.u15 += x.u1*d + c
	}

	// y.u15 * x
	if d := y.u15; d != 0 {
		z.u15 += x.u0 * d
	}

	return z
}

func (x Uint1024) mul512(y Uint512) Uint1024 {
	var z Uint1024
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		c, z.u7 = mulAddWWW(x.u7, d, c)
		c, z.u8 = mulAddWWW(x.u8, d, c)
		c, z.u9 = mulAddWWW(x.u9, d, c)
		c, z.u10 = mulAddWWW(x.u10, d, c)
		c, z.u11 = mulAddWWW(x.u11, d, c)
		c, z.u12 = mulAddWWW(x.u12, d, c)
		c, z.u13 = mulAddWWW(x.u13, d, c)
		c, z.u14 = mulAddWWW(x.u14, d, c)
		z.u15 += x.u15*d + c
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u6, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u7, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u8, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u9, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u10, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u11, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u12, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u13, d, z.u14, c)
		z.u15 += x.u14*d + c
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u5, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u6, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u7, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u8, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u9, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u10, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u11, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u12, d, z.u14, c)
		z.u15 += x.u13*d + c
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u4, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u5, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u6, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u7, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u8, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u9, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u10, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u11, d, z.u14, c)
		z.u15 += x.u12*d + c
	}

	// y.u4 * x
	if d := y.u4; d != 0 {
		c, z.u4 = mulAddWWW(x.u0, d, z.u4)
		c, z.u5 = mulAddWWWW(x.u1, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u2, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u3, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u4, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u5, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u6, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u7, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u8, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u9, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u10, d, z.u14, c)
		z.u15 += x.u11*d + c
	}

	// y.u5 * x
	if d := y.u5; d != 0 {
		c, z.u5 = mulAddWWW(x.u0, d, z.u5)
		c, z.u6 = mulAddWWWW(x.u1, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u2, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u3, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u4, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u5, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u6, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u7, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u8, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u9, d, z.u14, c)
		z.u15 += x.u10*d + c
	}

	// y.u6 * x
	if d := y.u6; d != 0 {
		c, z.u6 = mulAddWWW(x.u0, d, z.u6)
		c, z.u7 = mulAddWWWW(x.u1, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u2, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u3, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u4, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u5, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u6, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u7, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u8, d, z.u14, c)
		z.u15 += x.u9*d + c
	}

	// y.u7 * x
	if d := y.u7; d != 0 {
		c, z.u7 = mulAddWWW(x.u0, d, z.u7)
		c, z.u8 = mulAddWWWW(x.u1, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u2, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u3, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u4, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u5, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u6, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u7, d, z.u14, c)
		z.u15 += x.u8*d + c
	}

	return z
}

func (x Uint1024) mul64(y uint64) Uint1024 {
	if y == 0 {
		return Uint1024{}
	}
	var z Uint1024
	var c uint64
	c, z.u0 = bits.Mul64(x.u0, y)
	c, z.u1 = mulAddWWW(x.u1, y, c)
	c, z.u2 = mulAddWWW(x.u2, y, c)
	c, z.u3 = mulAddWWW(x.u3, y, c)
	c, z.u4 = mulAddWWW(x.u4, y, c)
	c, z.u5 = mulAddWWW(x.u5, y, c)
	c, z.u6 = mulAddWWW(x.u6, y, c)
	c, z.u7 = mulAddWWW(x.u7, y, c)
	c, z.u8 = mulAddWWW(x.u8, y, c)
	c, z.u9 = mulAddWWW(x.u9, y, c)
	c, z.u10 = mulAddWWW(x.u10, y, c)
	c, z.u11 = mulAddWWW(x.u11, y, c)
	c, z.u12 = mulAddWWW(x.u12, y, c)
	c, z.u13 = mulAddWWW(x.u13, y, c)
	c, z.u14 = mulAddWWW(x.u14, y, c)
	z.u15 += x.u15*y + c
	return z
}

// Exp return x^y mod m.
//
// If m == 0, Exp simply returns x^y.
func (x Uint1024) Exp(y, m Uint1024) Uint1024 {
	const mask = 1 << (64 - 1)

	// x^0 = 1
	if y.IsZero() {
		return U1024From64(1)
	}

	// x^1 mod m == x mod m
	mod := !m.IsZero()
	if y == U1024From64(1) && mod {
		_, r := x.QuoRem(m)
		return r
	}

	yv := []uint64{
		y.u0, y.u1, y.u2, y.u3, y.u4, y.u5, y.u6, y.u7, y.u8, y.u9, y.u10, y.u11, y.u12, y.u13, y.u14,
	}
	i := len(yv)
	for i > 0 && yv[i-1] == 0 {
		i--
	}
	yv = yv[:i]

	// TODO(eric): if x > 1 and y > 0 && mod, then use montgomery
	// or windowed exponentiation.

	z := x
	v := yv[len(yv)-1]
	s := bits.LeadingZeros64(v) + 1
	v <<= s
	w := 64 - s
	for j := 0; j < w; j++ {
		z = z.Mul(z)
		if v&mask != 0 {
			z = z.Mul(x)
		}
		if mod {
			_, z = z.QuoRem(m)
		}
		v <<= 1
	}

	for i := len(yv) - 2; i >= 0; i-- {
		v := yv[i]
		for j := 0; j < 64; j++ {
			z = z.Mul(z)
			if v&mask != 0 {
				z = z.Mul(x)
			}
			if mod {
				_, z = z.QuoRem(m)
			}
			v <<= 1
		}
	}
	return z
}

// mulPow10 returns x * 10^n.
func (x Uint1024) mulPow10(n uint) (Uint1024, bool) {
	switch {
	case x.IsZero():
		return Uint1024{}, true
	case n == 0:
		return x, true
	default:
		return x.MulCheck(U1024From64(10).Exp(U1024From64(uint64(n)), U1024From64(0)))
	}
}

var pow10tabUint1024 struct {
	values []Uint1024
	once   sync.Once
}

func pow10Uint1024(n uint) Uint1024 {
	pow10tabUint1024.once.Do(func() {
		tab := make([]Uint1024, 2+309)
		tab[0] = Uint1024{}
		tab[1] = U1024From64(1)
		for i := 2; i < len(tab); i++ {
			tab[i] = tab[i-1].mul64(10)
		}
		pow10tabUint1024.values = tab
	})
	return pow10tabUint1024.values[n]
}

// MulCheck returns x*y and reports whether the multiplication
// oveflowed.
func (x Uint1024) MulCheck(y Uint1024) (Uint1024, bool) {
	if x.BitLen()+y.BitLen() > 1024 {
		return Uint1024{}, false
	}

	var z Uint1024
	var c uint64

	// y.u0 * x
	if d := y.u0; d != 0 {
		c, z.u0 = bits.Mul64(x.u0, d)
		c, z.u1 = mulAddWWW(x.u1, d, c)
		c, z.u2 = mulAddWWW(x.u2, d, c)
		c, z.u3 = mulAddWWW(x.u3, d, c)
		c, z.u4 = mulAddWWW(x.u4, d, c)
		c, z.u5 = mulAddWWW(x.u5, d, c)
		c, z.u6 = mulAddWWW(x.u6, d, c)
		c, z.u7 = mulAddWWW(x.u7, d, c)
		c, z.u8 = mulAddWWW(x.u8, d, c)
		c, z.u9 = mulAddWWW(x.u9, d, c)
		c, z.u10 = mulAddWWW(x.u10, d, c)
		c, z.u11 = mulAddWWW(x.u11, d, c)
		c, z.u12 = mulAddWWW(x.u12, d, c)
		c, z.u13 = mulAddWWW(x.u13, d, c)
		c, z.u14 = mulAddWWW(x.u14, d, c)
		c, z.u15 = mulAddWWW(x.u15, d, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u1 * x
	if d := y.u1; d != 0 {
		c, z.u1 = mulAddWWW(x.u0, d, z.u1)
		c, z.u2 = mulAddWWWW(x.u1, d, z.u2, c)
		c, z.u3 = mulAddWWWW(x.u2, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u3, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u4, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u5, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u6, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u7, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u8, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u9, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u10, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u11, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u12, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u13, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u14, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u2 * x
	if d := y.u2; d != 0 {
		c, z.u2 = mulAddWWW(x.u0, d, z.u2)
		c, z.u3 = mulAddWWWW(x.u1, d, z.u3, c)
		c, z.u4 = mulAddWWWW(x.u2, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u3, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u4, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u5, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u6, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u7, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u8, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u9, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u10, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u11, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u12, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u13, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u3 * x
	if d := y.u3; d != 0 {
		c, z.u3 = mulAddWWW(x.u0, d, z.u3)
		c, z.u4 = mulAddWWWW(x.u1, d, z.u4, c)
		c, z.u5 = mulAddWWWW(x.u2, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u3, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u4, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u5, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u6, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u7, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u8, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u9, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u10, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u11, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u12, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u4 * x
	if d := y.u4; d != 0 {
		c, z.u4 = mulAddWWW(x.u0, d, z.u4)
		c, z.u5 = mulAddWWWW(x.u1, d, z.u5, c)
		c, z.u6 = mulAddWWWW(x.u2, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u3, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u4, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u5, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u6, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u7, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u8, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u9, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u10, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u11, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u5 * x
	if d := y.u5; d != 0 {
		c, z.u5 = mulAddWWW(x.u0, d, z.u5)
		c, z.u6 = mulAddWWWW(x.u1, d, z.u6, c)
		c, z.u7 = mulAddWWWW(x.u2, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u3, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u4, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u5, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u6, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u7, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u8, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u9, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u10, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u6 * x
	if d := y.u6; d != 0 {
		c, z.u6 = mulAddWWW(x.u0, d, z.u6)
		c, z.u7 = mulAddWWWW(x.u1, d, z.u7, c)
		c, z.u8 = mulAddWWWW(x.u2, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u3, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u4, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u5, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u6, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u7, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u8, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u9, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u7 * x
	if d := y.u7; d != 0 {
		c, z.u7 = mulAddWWW(x.u0, d, z.u7)
		c, z.u8 = mulAddWWWW(x.u1, d, z.u8, c)
		c, z.u9 = mulAddWWWW(x.u2, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u3, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u4, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u5, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u6, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u7, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u8, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u8 * x
	if d := y.u8; d != 0 {
		c, z.u8 = mulAddWWW(x.u0, d, z.u8)
		c, z.u9 = mulAddWWWW(x.u1, d, z.u9, c)
		c, z.u10 = mulAddWWWW(x.u2, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u3, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u4, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u5, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u6, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u7, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u9 * x
	if d := y.u9; d != 0 {
		c, z.u9 = mulAddWWW(x.u0, d, z.u9)
		c, z.u10 = mulAddWWWW(x.u1, d, z.u10, c)
		c, z.u11 = mulAddWWWW(x.u2, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u3, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u4, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u5, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u6, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u10 * x
	if d := y.u10; d != 0 {
		c, z.u10 = mulAddWWW(x.u0, d, z.u10)
		c, z.u11 = mulAddWWWW(x.u1, d, z.u11, c)
		c, z.u12 = mulAddWWWW(x.u2, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u3, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u4, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u5, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u11 * x
	if d := y.u11; d != 0 {
		c, z.u11 = mulAddWWW(x.u0, d, z.u11)
		c, z.u12 = mulAddWWWW(x.u1, d, z.u12, c)
		c, z.u13 = mulAddWWWW(x.u2, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u3, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u4, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u12 * x
	if d := y.u12; d != 0 {
		c, z.u12 = mulAddWWW(x.u0, d, z.u12)
		c, z.u13 = mulAddWWWW(x.u1, d, z.u13, c)
		c, z.u14 = mulAddWWWW(x.u2, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u3, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u13 * x
	if d := y.u13; d != 0 {
		c, z.u13 = mulAddWWW(x.u0, d, z.u13)
		c, z.u14 = mulAddWWWW(x.u1, d, z.u14, c)
		c, z.u15 = mulAddWWWW(x.u2, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u14 * x
	if d := y.u14; d != 0 {
		c, z.u14 = mulAddWWW(x.u0, d, z.u14)
		c, z.u15 = mulAddWWWW(x.u1, d, z.u15, c)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	// y.u15 * x
	if d := y.u15; d != 0 {
		c, z.u15 = mulAddWWW(x.u0, d, z.u15)
		if c != 0 {
			return Uint1024{}, false
		}
	}

	return z, true
}

func (x Uint1024) mulCheck64(y uint64) (Uint1024, bool) {
	if y == 0 {
		return Uint1024{}, true
	}
	var z Uint1024
	var c uint64
	c, z.u0 = bits.Mul64(x.u0, y)
	c, z.u1 = mulAddWWW(x.u1, y, c)
	c, z.u2 = mulAddWWW(x.u2, y, c)
	c, z.u3 = mulAddWWW(x.u3, y, c)
	c, z.u4 = mulAddWWW(x.u4, y, c)
	c, z.u5 = mulAddWWW(x.u5, y, c)
	c, z.u6 = mulAddWWW(x.u6, y, c)
	c, z.u7 = mulAddWWW(x.u7, y, c)
	c, z.u8 = mulAddWWW(x.u8, y, c)
	c, z.u9 = mulAddWWW(x.u9, y, c)
	c, z.u10 = mulAddWWW(x.u10, y, c)
	c, z.u11 = mulAddWWW(x.u11, y, c)
	c, z.u12 = mulAddWWW(x.u12, y, c)
	c, z.u13 = mulAddWWW(x.u13, y, c)
	c, z.u14 = mulAddWWW(x.u14, y, c)
	c, z.u15 = mulAddWWW(x.u15, y, c)
	if c != 0 {
		return Uint1024{}, false
	}
	return z, true
}

// QuoRem returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint1024) QuoRem(y Uint1024) (q, r Uint1024) {
	if x.Cmp(y) < 0 {
		// x/y for x < y = 0.
		// x%y for x < y = x.
		return Uint1024{}, x
	}

	if y.high().IsZero() {
		q, rr := x.quoRem512(y.low())
		return q, u1024(rr, Uint512{})
	}

	n := uint(y.high().LeadingZeros())
	y1 := y.Lsh(n) // y1 := y<<n
	x1 := x.Rsh(1) // x1 := x>>1
	tq, _ := div512(x1.high(), x1.low(), y1.high())
	tq = tq.Rsh(511 - n) // tq >>= 511 - n
	if !tq.IsZero() {
		tq = tq.sub64(1) // tq--
	}
	q = u1024(tq, Uint512{})
	ytq := y.mul512(tq) // ytq := y*tq
	r = x.Sub(ytq)      // r = x-ytq
	if r.Cmp(y) >= 0 {
		q = q.add64(1) // q++
		r = r.Sub(y)   // r -= y
	}
	return
}

// quoRem512 returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint1024) quoRem512(y Uint512) (q Uint1024, r Uint512) {
	if x.high().Cmp(y) < 0 {
		lo, r := div512(x.high(), x.low(), y)
		return u1024(lo, Uint512{}), r
	}
	hi, r := div512(Uint512{}, x.high(), y)
	lo, r := div512(r, x.low(), y)
	return u1024(lo, hi), r
}

// quoRem64 returns (q, r) such that
//
//	q = x/y
//	r = x - y*q
func (x Uint1024) quoRem64(y uint64) (q Uint1024, r uint64) {
	q.u15, r = bits.Div64(0, x.u15, y)
	q.u14, r = bits.Div64(r, x.u14, y)
	q.u13, r = bits.Div64(r, x.u13, y)
	q.u12, r = bits.Div64(r, x.u12, y)
	q.u11, r = bits.Div64(r, x.u11, y)
	q.u10, r = bits.Div64(r, x.u10, y)
	q.u9, r = bits.Div64(r, x.u9, y)
	q.u8, r = bits.Div64(r, x.u8, y)
	q.u7, r = bits.Div64(r, x.u7, y)
	q.u6, r = bits.Div64(r, x.u6, y)
	q.u5, r = bits.Div64(r, x.u5, y)
	q.u4, r = bits.Div64(r, x.u4, y)
	q.u3, r = bits.Div64(r, x.u3, y)
	q.u2, r = bits.Div64(r, x.u2, y)
	q.u1, r = bits.Div64(r, x.u1, y)
	q.u0, r = bits.Div64(r, x.u0, y)
	return q, r
}

// div1024 returns (q, r) such that
//
//	q = (hi, lo)/y
//	r = (hi, lo) - y*q
func div1024(hi, lo, y Uint1024) (q, r Uint1024) {
	if y.IsZero() {
		panic("integer divide by zero")
	}
	if y.Cmp(hi) <= 0 {
		panic("integer overflow")
	}

	s := uint(y.LeadingZeros())
	y = y.Lsh(s)    // y = y<<s
	yn1 := y.high() // yn1 := y >> 512
	yn0 := y.low()  // yn0 := y & mask512

	un32 := hi.Lsh(s).Or(lo.Rsh(1024 - s)) // un32 := hi<<s | lo>>(1024-s)
	un10 := lo.Lsh(s)                      // un10 := lo<<s
	un1 := un10.high()                     // un1 := un10 >> 512
	un0 := un10.low()                      // un0 := un10 & mask512
	q1, rhat := un32.quoRem512(yn1)

	var c uint64 // rhat + yn1 carry

	// for q1 >= two512 || q1*yn0 > two512*rhat+un1 { ... }
	for !q1.high().IsZero() || q1.mul512(yn0).Cmp(u1024(un1, rhat)) > 0 {
		q1 = q1.sub64(1)             // q1--
		rhat, c = rhat.AddCheck(yn1) // rhat += yn1
		if c != 0 {
			break
		}
	}

	// un21 := un32*two512 + un1 - q1*y
	un21 := u1024(un1, un32.low()).Sub(q1.Mul(y))
	q0, rhat := un21.quoRem512(yn1)

	// for q0 >= two512 || q0*yn0 > two512*rhat+un0 { ... }
	for !q0.high().IsZero() || q0.mul512(yn0).Cmp(u1024(un0, rhat)) > 0 {
		q0 = q0.sub64(1)             // q0--
		rhat, c = rhat.AddCheck(yn1) // rhat += yn1
		if c != 0 {
			break
		}
	}

	// q = q1*two512 + q0
	q = u1024(q0.low(), q1.low())
	// r = (un21*two512 + un0 - q0*y) >> s
	r = u1024(un0, un21.low()).Sub(q0.Mul(y)).Rsh(s)
	return
}

func (x Uint1024) GoString() string {
	return fmt.Sprintf("[%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d]",
		x.u0,
		x.u1,
		x.u2,
		x.u3,
		x.u4,
		x.u5,
		x.u6,
		x.u7,
		x.u8,
		x.u9,
		x.u10,
		x.u11,
		x.u12,
		x.u13,
		x.u14,
		x.u15,
	)
}

// String returns the base-10 representation of x.
func (x Uint1024) String() string {
	b := make([]byte, 309)
	i := len(b)
	for x.cmp64(10) >= 0 {
		q, r := x.quoRem64(10)
		i--
		b[i] = byte(r + '0')
		x = q
	}
	i--
	b[i] = byte(x.u0 + '0')
	return string(b[i:])
}

// ParseUint1024 returns the value of s in the given base.
func ParseUint1024(s string, base int) (Uint1024, error) {
	x, _, _, err := parseUint[Uint1024](s, base, false)
	return x, err
}
