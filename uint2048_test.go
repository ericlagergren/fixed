// Code generated by 'gen'. DO NOT EDIT.

package fixed

import (
	"math/big"
	"math/bits"
	"testing"

	"golang.org/x/exp/rand"
)

var (
	big2048mask    = bigMask(2048)
	bigMaxUint2048 = Uint2048{}.max().big()
)

func randUint2048() Uint2048 {
	var x Uint2048
	if randBool() {
		x.u0 = randUint64()
	}
	if randBool() {
		x.u1 = randUint64()
	}
	if randBool() {
		x.u2 = randUint64()
	}
	if randBool() {
		x.u3 = randUint64()
	}
	if randBool() {
		x.u4 = randUint64()
	}
	if randBool() {
		x.u5 = randUint64()
	}
	if randBool() {
		x.u6 = randUint64()
	}
	if randBool() {
		x.u7 = randUint64()
	}
	if randBool() {
		x.u8 = randUint64()
	}
	if randBool() {
		x.u9 = randUint64()
	}
	if randBool() {
		x.u10 = randUint64()
	}
	if randBool() {
		x.u11 = randUint64()
	}
	if randBool() {
		x.u12 = randUint64()
	}
	if randBool() {
		x.u13 = randUint64()
	}
	if randBool() {
		x.u14 = randUint64()
	}
	if randBool() {
		x.u15 = randUint64()
	}
	if randBool() {
		x.u16 = randUint64()
	}
	if randBool() {
		x.u17 = randUint64()
	}
	if randBool() {
		x.u18 = randUint64()
	}
	if randBool() {
		x.u19 = randUint64()
	}
	if randBool() {
		x.u20 = randUint64()
	}
	if randBool() {
		x.u21 = randUint64()
	}
	if randBool() {
		x.u22 = randUint64()
	}
	if randBool() {
		x.u23 = randUint64()
	}
	if randBool() {
		x.u24 = randUint64()
	}
	if randBool() {
		x.u25 = randUint64()
	}
	if randBool() {
		x.u26 = randUint64()
	}
	if randBool() {
		x.u27 = randUint64()
	}
	if randBool() {
		x.u28 = randUint64()
	}
	if randBool() {
		x.u29 = randUint64()
	}
	if randBool() {
		x.u30 = randUint64()
	}
	if randBool() {
		x.u31 = randUint64()
	}
	return x
}

func (x Uint2048) big() *big.Int {
	var v big.Int
	if bits.UintSize == 32 {
		v.SetBits([]big.Word{
			big.Word(x.u0),
			big.Word(x.u0 >> 32),
			big.Word(x.u1),
			big.Word(x.u1 >> 32),
			big.Word(x.u2),
			big.Word(x.u2 >> 32),
			big.Word(x.u3),
			big.Word(x.u3 >> 32),
			big.Word(x.u4),
			big.Word(x.u4 >> 32),
			big.Word(x.u5),
			big.Word(x.u5 >> 32),
			big.Word(x.u6),
			big.Word(x.u6 >> 32),
			big.Word(x.u7),
			big.Word(x.u7 >> 32),
			big.Word(x.u8),
			big.Word(x.u8 >> 32),
			big.Word(x.u9),
			big.Word(x.u9 >> 32),
			big.Word(x.u10),
			big.Word(x.u10 >> 32),
			big.Word(x.u11),
			big.Word(x.u11 >> 32),
			big.Word(x.u12),
			big.Word(x.u12 >> 32),
			big.Word(x.u13),
			big.Word(x.u13 >> 32),
			big.Word(x.u14),
			big.Word(x.u14 >> 32),
			big.Word(x.u15),
			big.Word(x.u15 >> 32),
			big.Word(x.u16),
			big.Word(x.u16 >> 32),
			big.Word(x.u17),
			big.Word(x.u17 >> 32),
			big.Word(x.u18),
			big.Word(x.u18 >> 32),
			big.Word(x.u19),
			big.Word(x.u19 >> 32),
			big.Word(x.u20),
			big.Word(x.u20 >> 32),
			big.Word(x.u21),
			big.Word(x.u21 >> 32),
			big.Word(x.u22),
			big.Word(x.u22 >> 32),
			big.Word(x.u23),
			big.Word(x.u23 >> 32),
			big.Word(x.u24),
			big.Word(x.u24 >> 32),
			big.Word(x.u25),
			big.Word(x.u25 >> 32),
			big.Word(x.u26),
			big.Word(x.u26 >> 32),
			big.Word(x.u27),
			big.Word(x.u27 >> 32),
			big.Word(x.u28),
			big.Word(x.u28 >> 32),
			big.Word(x.u29),
			big.Word(x.u29 >> 32),
			big.Word(x.u30),
			big.Word(x.u30 >> 32),
			big.Word(x.u31),
			big.Word(x.u31 >> 32),
		})
	} else {
		v.SetBits([]big.Word{
			big.Word(x.u0),
			big.Word(x.u1),
			big.Word(x.u2),
			big.Word(x.u3),
			big.Word(x.u4),
			big.Word(x.u5),
			big.Word(x.u6),
			big.Word(x.u7),
			big.Word(x.u8),
			big.Word(x.u9),
			big.Word(x.u10),
			big.Word(x.u11),
			big.Word(x.u12),
			big.Word(x.u13),
			big.Word(x.u14),
			big.Word(x.u15),
			big.Word(x.u16),
			big.Word(x.u17),
			big.Word(x.u18),
			big.Word(x.u19),
			big.Word(x.u20),
			big.Word(x.u21),
			big.Word(x.u22),
			big.Word(x.u23),
			big.Word(x.u24),
			big.Word(x.u25),
			big.Word(x.u26),
			big.Word(x.u27),
			big.Word(x.u28),
			big.Word(x.u29),
			big.Word(x.u30),
			big.Word(x.u31),
		})
	}
	return &v
}

func TestUint2048Bytes(t *testing.T) {
	for i := 0; i < 250_000; i++ {
		x := randUint2048()
		var b [256]byte
		x.Bytes(&b)
		var y Uint2048
		if err := y.SetBytes(b[:]); err != nil {
			t.Fatal(err)
		}
		if x != y {
			t.Fatalf("got %x, expected %x", y, x)
		}
	}
}
func TestUint2048BitLen(t *testing.T) {
	for i := 0; i < 250_000; i++ {
		x := randUint2048()

		got := x.BitLen()
		want := x.big().BitLen()
		if got != want {
			t.Fatalf("expected %d, got %d", want, got)
		}
	}
}

func TestUint2048LeadingZeros(t *testing.T) {
	for i := 0; i < 250_000; i++ {
		x := randUint2048()

		got := x.LeadingZeros()
		want := 2048 - x.big().BitLen()
		if got != want {
			t.Fatalf("expected %d, got %d", want, got)
		}
	}
}

func TestUint2048Cmp(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		got := x.Cmp(y)
		want := x.big().Cmp(y.big())
		if got != want {
			t.Fatalf("Cmp(%d, %d): expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048And(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z := x.And(y)

		want := new(big.Int).And(x.big(), y.big())
		want.And(want, big2048mask)

		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d + %d: expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Or(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z := x.Or(y)

		want := new(big.Int).Or(x.big(), y.big())
		want.And(want, big2048mask)

		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d + %d: expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Xor(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z := x.Xor(y)

		want := new(big.Int).Xor(x.big(), y.big())
		want.And(want, big2048mask)

		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d + %d: expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Lsh(t *testing.T) {
	for i := 0; i < 1_000_000; i++ {
		x := randUint2048()
		n := uint(rand.Intn(2048 + 1))

		z := x.Lsh(n)

		want := new(big.Int).Lsh(x.big(), n)
		want.And(want, big2048mask)

		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d << %d: expected %d, got %d",
				x.big(), n, want, got)
		}
	}
}

func TestUint2048Rsh(t *testing.T) {
	for i := 0; i < 1_000_000; i++ {
		x := randUint2048()
		n := uint(rand.Intn(2048 + 1))

		z := x.Rsh(n)

		want := new(big.Int).Rsh(x.big(), n)
		want.And(want, big2048mask)

		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d >> %d: expected %d, got %d",
				x.big(), n, want, got)
		}
	}
}

func TestUint2048Add(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z, c := x.AddCheck(y)

		want := new(big.Int).Add(x.big(), y.big())
		if carry := want.Cmp(bigMaxUint2048) > 0; carry != (c == 1) {
			t.Fatalf("%d + %d: expected %t, got %t",
				x.big(), y.big(), carry, c == 1)
		}
		want.And(want, big2048mask)

		if c == 0 && x.Add(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), y.big(), x.Add(y), z)
		}
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d + %d: expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Add64(t *testing.T) {
	for i := 0; i < 250_000; i++ {
		x := randUint2048()
		y := randUint64()

		z, c := x.addCheck64(y)

		ybig := new(big.Int).SetUint64(y)
		want := new(big.Int).Add(x.big(), ybig)
		if carry := want.Cmp(bigMaxUint2048) > 0; carry != (c == 1) {
			t.Fatalf("%d + %d: expected %t, got %t",
				x.big(), ybig, carry, c == 1)
		}
		want.And(want, big2048mask)

		if c == 0 && x.add64(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), ybig, x.add64(y), z)
		}
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d + %d: expected %d, got %d",
				x.big(), ybig, want, got)
		}
	}
}

func TestUint2048Sub(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z, b := x.SubCheck(y)

		want := new(big.Int).Sub(x.big(), y.big())
		if borrow := want.Sign() < 0; borrow != (b == 1) {
			t.Fatalf("%d - %d: expected %t, got %t",
				x.big(), y.big(), borrow, b == 1)
		}
		want.And(want, big2048mask)

		if b == 0 && x.Sub(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), y.big(), x.Sub(y), z)
		}
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d - %d: expected %d, got %d",
				x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Sub64(t *testing.T) {
	for i := 0; i < 250_000; i++ {
		x := randUint2048()
		y := randUint64()

		z, b := x.subCheck64(y)

		ybig := new(big.Int).SetUint64(y)
		want := new(big.Int).Sub(x.big(), ybig)
		if borrow := want.Sign() < 0; borrow != (b == 1) {
			t.Fatalf("%d - %d: expected %t, got %t",
				x.big(), ybig, borrow, b == 1)
		}
		want.And(want, big2048mask)

		if b == 0 && x.sub64(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), ybig, x.sub64(y), z)
		}
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d - %d: expected %d, got %d",
				x.big(), ybig, want, got)
		}
	}
}

func TestUint2048Mul(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()

		z, ok := x.MulCheck(y)

		want := new(big.Int).Mul(x.big(), y.big())
		if (want.Cmp(bigMaxUint2048) <= 0) != ok {
			t.Fatalf("%d: %d * %d: expected %t",
				i, x.big(), y.big(), !ok)
		}
		want.And(want, big2048mask)

		if ok && x.Mul(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), y.big(), x.Mul(y), z)
		}
		z = x.Mul(y)
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d: %d * %d: expected %d, got %d",
				i, x.big(), y.big(), want, got)
		}
	}
}

func TestUint2048Mul64(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint64()

		z, ok := x.mulCheck64(y)

		ybig := new(big.Int).SetUint64(y)
		want := new(big.Int).Mul(x.big(), ybig)
		if (want.Cmp(bigMaxUint2048) <= 0) != ok {
			t.Fatalf("%d: %d * %d: expected %t",
				i, x.big(), ybig, !ok)
		}
		want.And(want, big2048mask)

		if ok && x.mul64(y) != z {
			t.Fatalf("%d: %d * %d: %d != %d",
				i, x.big(), ybig, x.mul64(y), z)
		}
		z = x.mul64(y)
		if got := z.big(); got.Cmp(want) != 0 {
			t.Fatalf("%d: %d * %d: expected %d, got %d",
				i, x.big(), ybig, want, got)
		}
	}
}

func TestUint2048Exp(t *testing.T) {
	x := U2048(1)
	ten := U2048(10)
	for i := 1; ; i++ {
		want, ok := x.mulCheck64(10)
		if !ok {
			break
		}
		got := ten.Exp(U2048(uint64(i)), U2048(0))
		if got != want {
			t.Fatalf("#%d: expected %q, got %q", i, want, got)
		}
		x = want
	}
}

func TestUint2048QuoRem(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint2048()
		if y.IsZero() {
			y = U2048(1)
		}

		q, r := x.QuoRem(y)

		wantq := new(big.Int)
		wantr := new(big.Int)
		wantq.QuoRem(x.big(), y.big(), wantr)
		wantq.And(wantq, big2048mask)

		if got := q.big(); got.Cmp(wantq) != 0 {
			t.Fatalf("%d / %d expected quotient of %d, got %d",
				x.big(), y.big(), wantq, got)
		}
		if got := r.big(); got.Cmp(wantr) != 0 {
			t.Fatalf("%d / %d expected remainder of %d, got %d",
				x.big(), y.big(), wantr, got)
		}
	}
}

func TestUint2048QuoRemHalf(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint1024()
		if y.IsZero() {
			y = U1024(1)
		}

		q, r := x.quoRem1024(y)

		wantq := new(big.Int)
		wantr := new(big.Int)
		wantq.QuoRem(x.big(), y.big(), wantr)
		wantq.And(wantq, big2048mask)

		if got := q.big(); got.Cmp(wantq) != 0 {
			t.Fatalf("%d / %d expected quotient of %d, got %d",
				x.big(), y.big(), wantq, got)
		}
		if got := r.big(); got.Cmp(wantr) != 0 {
			t.Fatalf("%d / %d expected remainder of %d, got %d",
				x.big(), y.big(), wantr, got)
		}
	}
}

func TestUint2048QuoRem64(t *testing.T) {
	for i := 0; i < 100_000; i++ {
		x := randUint2048()
		y := randUint64()
		if y == 0 {
			y = 1
		}

		q, r := x.quoRem64(y)

		ybig := new(big.Int).SetUint64(y)
		wantq := new(big.Int)
		wantr := new(big.Int)
		wantq.QuoRem(x.big(), ybig, wantr)
		wantq.And(wantq, big2048mask)

		if got := q.big(); got.Cmp(wantq) != 0 {
			t.Fatalf("%d / %d expected quotient of %d, got %d",
				x.big(), ybig, wantq, got)
		}
		if got := new(big.Int).SetUint64(r); got.Cmp(wantr) != 0 {
			t.Fatalf("%d / %d expected remainder of %d, got %d",
				x.big(), ybig, wantr, got)
		}
	}
}

func TestUint2048String(t *testing.T) {
	test := func(x Uint2048) {
		want := x.big().String()
		got := x.String()
		if want != got {
			t.Fatalf("expected %q, got %q", want, got)
		}
	}
	test(Uint2048{})       // min
	test(Uint2048{}.max()) // max
	for i := 0; i < 10_000; i++ {
		test(randUint2048())
	}
}

func TestParseUint2048(t *testing.T) {
	for i := 0; i < 10_000; i++ {
		want := randUint2048()
		b := want.big()
		for base := 2; base <= 36; base++ {
			s := b.Text(base)
			got, err := ParseUint2048(s, base)
			if err != nil {
				t.Fatalf("%q in base %d: unexpected error: %v", s, base, err)
			}
			if got != want {
				t.Fatalf("%q in base %d: expected %#v, got %#v",
					s, base, want, got)
			}
		}
	}
}

func BenchmarkUint2048Add(b *testing.B) {
	s := make([]Uint2048, 1000)
	for i := range s {
		s[i] = randUint2048()
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		x := s[i%len(s)]
		y := s[(i+1)%len(s)]
		sink.Uint2048 = x.Add(y)
	}
}

func BenchmarkUint2048Sub(b *testing.B) {
	s := make([]Uint2048, 1000)
	for i := range s {
		s[i] = randUint2048()
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		x := s[i%len(s)]
		y := s[(i+1)%len(s)]
		sink.Uint2048 = x.Sub(y)
	}
}

func BenchmarkUint2048Mul(b *testing.B) {
	s := make([]Uint2048, 1000)
	for i := range s {
		s[i] = randUint2048()
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		x := s[i%len(s)]
		y := s[(i+1)%len(s)]
		sink.Uint2048 = x.Mul(y)
	}
}

func BenchmarkUint2048QuoRem(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sink.Uint2048, sink.Uint2048 = U2048(uint64(i + 2)).QuoRem(U2048(uint64(i + 1)))
	}
}

func BenchmarkUint2048QuoRem64(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sink.Uint2048, sink.uint64 = U2048(uint64(i + 2)).quoRem64(uint64(i + 1))
	}
}
